<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>司法試験 論証タイピング</title>
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="apple-touch-icon" href="icons/icon-180.png">
  <meta name="theme-color" content="#0d1b32">
  <!-- Chart.jsライブラリの読み込み -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Lucide Iconsライブラリの読み込み -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    /* ==================================================
       ANIMATION REFRESH THEME (Ivory, Navy, Gold)
       ================================================== */
    :root{
      /* Color Palette */
      --bg: #f9f9f9;
      --bg-subtle: #f0f2f5;
      --panel: #ffffff;
      --ink: #1a202c;
      --ink-2: #4a5568;
      --line: #e2e8f0;
      --accent: #0d1b32;
      --accent-light: #1a3a6e;
      --accent-2: #c5984b;
      --accent-soft: #edf2f7;
      
      /* Typography */
      --font-sans: "SF Pro Text", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                   "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Source Han Sans JP", "Yu Gothic",
                   Meiryo, Arial, sans-serif;
      --font-serif: "Hiragino Mincho ProN", "Yu Mincho", "Noto Serif JP", "Source Han Serif JP",
                   Georgia, "Times New Roman", serif;

      /* Sizing & Radius */
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;

      /* Shadows (Layered) */
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-focus: 0 0 0 3px rgba(197, 152, 75, 0.3);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--font-sans);
      color:var(--ink); background:var(--bg); letter-spacing:.01em;
      -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
      transition: padding-left 0.3s ease;
    }
    body.modal-open {
      overflow: hidden;
    }
    h1,h2,h3{
      font-family: var(--font-serif);
      font-weight:700; letter-spacing:.02em;
    }
    h2{ font-size:1.25rem; margin:.1rem 0 .8rem 0; font-weight:800; color: var(--accent); }
    h3{ font-size:1.1rem; margin:.2rem 0 .6rem 0; font-weight:700; color: var(--ink) }
    small,.muted{font-size:.875rem; color:var(--ink-2); letter-spacing:.01em}
    .container, main, #app, .page{max-width:1200px; margin:0 auto; padding:1.5rem}
    .section{margin-top:1.5rem}
    .card{
      background: var(--panel);
      border:1px solid var(--line);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-md);
      padding:1.5rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .list-item{
      border:1px solid var(--line); border-radius:var(--radius-md); background:#fff; padding:1rem 1.25rem;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .list-item:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-lg);
      border-color: var(--accent-2);
    }

    /* Controls */
    button{
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      line-height:1; border-radius:var(--radius-sm);
      font-weight:600; font-family: var(--font-sans);
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      cursor: pointer;
      padding: 0.6rem 1rem;
      border: 1px solid transparent;
      box-shadow: var(--shadow-sm);
    }
    button:hover { 
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    button:active {
      transform: translateY(0px);
      box-shadow: var(--shadow-sm);
      filter: brightness(0.95);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      filter: none;
      transform: none;
      box-shadow: none;
    }
    button.primary{
      background:linear-gradient(180deg, var(--accent-light) 0%, var(--accent) 100%);
      border-color: var(--accent); color:#fff;
    }
    button.ghost{
      border-color: var(--line); background:var(--panel); color: var(--ink);
    }
    button.ghost:hover{ border-color:var(--accent-2); background-color: var(--accent-soft); color: var(--accent); }
    .badge{ display:inline-flex; align-items:center; justify-content:center; min-width:24px; height:22px; padding:0 .5rem;
      border-radius:999px; background:var(--accent-2); color:#fff; font-weight:600; font-size:.75rem }
    .pill{ display:inline-flex; align-items:center; padding:.25rem .75rem; border:1px solid var(--line); border-radius:999px; background:var(--bg-subtle); font-weight:600; font-size: 0.8rem; }
    
    /* Inputs */
    input, select, textarea{ width:100%; background:var(--panel); color:var(--ink); border:1px solid var(--line);
      border-radius:var(--radius-sm); padding:.75rem; font:inherit; transition: all 0.2s ease; }
    input:focus, select:focus, textarea:focus{ outline:none; box-shadow:var(--shadow-focus); border-color:var(--accent-2); }
    textarea{ font-size:16px; line-height:1.6 }

    /* Filter Bar */
    .filter-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background-color: var(--bg-subtle);
      border-radius: var(--radius-md);
      flex-wrap: wrap;
    }
    .filter-group {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      flex-wrap: wrap;
    }
    .filter-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .filter-item label {
      white-space: nowrap;
      font-weight: 600;
      color: var(--ink-2);
    }
    .filter-item select,
    .filter-item input {
      width: auto;
      min-width: 120px;
      padding: 0.5rem 0.75rem;
    }
    .filter-item input[type="number"] {
      max-width: 100px;
    }

    /* Settings Page Specific Styles */
    .settings-section {
      border-top: 1px solid var(--line);
      padding-top: 1.5rem;
      margin-top: 1.5rem;
    }
    .settings-section:first-of-type {
      border-top: none;
      padding-top: 0;
      margin-top: 0;
    }
    .settings-section h3 {
      margin-top: 0;
      margin-bottom: 1rem;
    }
    .settings-content {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .settings-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 0;
    }
    .settings-item-info {
      padding-right: 1rem;
    }
    .settings-item-info strong {
      display: block;
      color: var(--ink);
    }
    .settings-item-info .muted {
      font-size: 0.875rem;
      margin: 0.25rem 0 0 0;
    }
    .settings-item-control {
      flex-shrink: 0;
    }
    /* Custom switch for checkbox */
    .switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 24px;
    }
    .switch input { 
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 24px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider {
      background-color: var(--accent);
    }
    input:checked + .slider:before {
      transform: translateX(16px);
    }


    /* ================== RAIL & TABBAR LAYOUT ================== */
    #rail{
      position:fixed; left:0; top:0; bottom:0; width:240px;
      background:linear-gradient(180deg, var(--accent) 0%, #081428 100%); color:#eaf2ff;
      border-right:1px solid rgba(255,255,255,.1);
      display:none; flex-direction:column; padding:1.25rem 1rem; gap:0.75rem; z-index:49;
    }
    #rail .logo {
      display: flex;
      align-items: center;
      gap: 12px;
      padding-bottom: 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      margin-bottom: 1rem;
    }
    #rail .logo .logo-icon {
      color: var(--accent-2);
      flex-shrink: 0;
    }
    #rail .logo .logo-text {
      font-family: var(--font-sans);
      font-weight: 700;
      font-size: 1.1rem;
      color: #fff;
      letter-spacing: .03em;
    }
    #rail .nav{ display:flex; flex-direction:column; gap:6px; margin-top:10px }
    #rail .nav button{
      display:flex; align-items:center; gap:12px;
      height:44px; padding:0 14px; font-size:1rem; border-radius:var(--radius-sm);
      background:transparent; color:#eaf2ff; border:none;
      font-weight:700; cursor:pointer; justify-content: flex-start;
      transition: all 0.2s ease;
      box-shadow: none;
    }
    #rail .nav button:hover{ background:rgba(255,255,255,.1); transform: none; }
    #rail .nav button.active{ background:var(--accent-2); color:var(--accent); }
    #rail .nav button .lucide { width: 20px; height: 20px; }
    #rail .spacer{ flex:1 }
    #rail .mode{ border-top:1px solid rgba(255,255,255,.1); padding-top:1rem; display:grid; gap:8px }
    #rail .mode .seg{ display:grid; grid-template-columns:1fr 1fr; gap:8px }
    #rail .mode .seg button{ height:36px; font-size:.9rem; border-radius:var(--radius-sm); border:1px solid rgba(255,255,255,.15); background:transparent; color:#fff; font-weight:800; box-shadow: none; }
    #rail .mode .seg button.active{ background:#fff; color:var(--accent) }

    #mobile-header { display: none; }
    #tabbar{
      display:flex; align-items:center; justify-content:space-around;
      background:var(--panel); color:var(--ink);
      height: 60px;
    }
    #tabbar .item{ display:flex; flex-direction:column; gap:2px; align-items:center; justify-content:center; flex:1; padding: 4px 0; }
    #tabbar .item button{ background:transparent; border:0; color:var(--ink-2); font-size:.75rem; font-weight:600; padding: 0; box-shadow: none; }
    #tabbar .item .lucide{ width:22px; height:22px; color: var(--ink-2); }
    #tabbar .item.active button{ color:var(--accent) }
    #tabbar .item.active .lucide{ color:var(--accent) }

    .mode-switcher-mobile {
      background: var(--bg-subtle);
      padding: 8px 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      border-bottom: 1px solid var(--line);
    }
    .mode-switcher-mobile small { color: var(--ink-2); font-weight: 600; }
    .mode-switcher-mobile .seg {
      display: flex;
      background: var(--line);
      border-radius: var(--radius-sm);
      padding: 2px;
    }
    .mode-switcher-mobile .seg button {
      padding: 4px 12px;
      border: none;
      background: transparent;
      color: var(--ink-2);
      font-size: 0.85rem;
      font-weight: 700;
      border-radius: 6px;
      box-shadow: none;
    }
    .mode-switcher-mobile .seg button.active {
      background: var(--panel);
      color: var(--accent);
      box-shadow: var(--shadow-sm);
    }

    @media(min-width: 1000px){
      #rail{ display:flex }
      body{ padding-left:240px }
      #tabbar { display: none; }
    }
    @media(max-width: 999px){
      #mobile-header {
        display: block;
        position:fixed; 
        top:0; 
        left:0; 
        right:0;
        z-index: 50;
        background: var(--panel);
        padding-top: env(safe-area-inset-top);
        box-shadow: var(--shadow-md);
      }
      #tabbar {
        border-bottom: 1px solid var(--line);
      }
      body{ 
        padding-top: calc(55px + 60px + env(safe-area-inset-top)); 
        padding-bottom: 100px;
      } 
    }
    
    html.iphone #tabbar .item[data-nav="exit"]{ display:flex !important; }
    
    /* Helper classes */
    .flex{display:flex; gap:.75rem; align-items:center; flex-wrap:wrap}
    .row-sm{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
    .space{flex:1 1 auto}
    .hidden{display:none}

    /* Error overlay */
    #errlayer{position:fixed;inset:0;background:rgba(0,0,0,.6);color:#fff;z-index:9999;display:none;align-items:center;justify-content:center;padding:1rem}
    #errbox{background:#111;border:1px solid #444;max-width:900px;width:100%;padding:1rem;border-radius:.75rem}
    #errbox pre{white-space:pre-wrap;word-break:break-word;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:.85rem;background:#000;padding:.75rem;border-radius:.5rem;color:#0f0;max-height:50vh;overflow:auto}
  
    /* ================== ANIMATIONS ================== */
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
    @keyframes fadeInUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes modal-pop-in { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
    @keyframes modal-pop-out { from { opacity: 1; transform: scale(1); } to { opacity: 0; transform: scale(0.95); } }

    .page-container {
      animation: fadeIn 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    .animated-list-item {
      opacity: 0; /* Start hidden */
      animation: fadeInUp 0.5s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }

    /* Modal Animations */
    #modal-root .mask{
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      z-index: 1000;
      background:rgba(10,20,40,.5); 
      backdrop-filter: blur(4px);
      animation: fadeIn 0.3s ease-out forwards;
    }
    #modal-root .modal{
      background:var(--panel);
      color:var(--ink);
      width:min(680px,96vw);
      max-height:85vh;
      overflow:auto;
      border-radius:var(--radius-lg);
      padding:1.5rem;
      box-shadow:var(--shadow-lg);
      animation: modal-pop-in 0.3s ease-out 0.1s forwards;
    }
    #modal-root .mask.closing {
      animation: fadeOut 0.3s ease-out forwards;
    }
    #modal-root .mask.closing .modal {
      animation: modal-pop-out 0.3s ease-out forwards;
    }
    
    /* Misc */
    mark.hit{background:#fef08a}
    mark.miss, .kw-miss, .highlight-miss{
      background:#fecdd3 !important; color:inherit; border-radius:4px;
      box-shadow:0 0 0 1px rgba(255, 105, 180, .15) inset;
    }
    .cloze-card .cloze-slot{padding:0 3px;border-bottom:2px dotted #9ca3af;cursor:pointer;border-radius:4px;transition:background .15s, border-color .15s}
    .cloze-card .cloze-slot.ok{background:rgba(16, 185, 129, .1);border-bottom-color:#10b981}
    .cloze-card .cloze-slot.miss{background:rgba(239, 68, 68, .1);border-bottom-color:#ef4444}
    .cloze-card .cloze-slot.empty{background:rgba(0,0,0,.06);border-bottom-color:#bbb}
    .cloze-inputs{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:.5rem}
    .cloze-inputs input.ok{outline:2px solid #10b981}
    .cloze-inputs input.miss{outline:2px solid #ef4444}
    #rail .nav button[data-nav="exit"]{ display:none !important; }
    #tabbar .item[data-nav="exit"]{ display:none !important; }

    /* --- 新しいホーム画面のスタイル --- */
    .home-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1.5rem;
    }
    .stat-card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius-lg);
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      box-shadow: var(--shadow-md);
    }
    .stat-card .value {
      font-size: 2.75rem;
      font-weight: 800;
      color: var(--accent);
      line-height: 1;
    }
    .stat-card .value .unit {
      font-size: 1rem;
      font-weight: 600;
      color: var(--ink-2);
      margin-left: 0.25rem;
    }
    .stat-card .label {
      font-size: 0.9rem;
      font-weight: 700;
      color: var(--ink-2);
    }
    
    /* --- トースト通知のスタイル --- */
    #toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 10000;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .toast {
      padding: 12px 20px;
      border-radius: var(--radius-md);
      color: #fff;
      font-weight: 700;
      box-shadow: var(--shadow-lg);
      opacity: 0;
      transform: translateY(20px);
      animation: toast-in 0.5s forwards;
    }
    .toast.success { background-color: #16a34a; }
    .toast.info { background-color: var(--accent); }
    @keyframes toast-in { to { opacity: 1; transform: translateY(0); } }
    @keyframes toast-out { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(20px); } }
    
    /* --- 復習ページの新しいスタイル --- */
    .review-tabs {
      display: flex;
      gap: 0.5rem;
      border-bottom: 2px solid var(--line);
      margin-bottom: 1.5rem;
    }
    .review-tab {
      padding: 0.75rem 0.25rem;
      border: none;
      background: transparent;
      cursor: pointer;
      font-weight: 700;
      color: var(--ink-2);
      border-bottom: 3px solid transparent;
      margin-bottom: -2px;
      transition: all 0.2s ease;
      box-shadow: none;
    }
    .review-tab:hover { color: var(--accent); transform: none; box-shadow: none; }
    .review-tab.active {
      color: var(--accent);
      border-bottom-color: var(--accent-2);
    }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .action-card {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: var(--radius-lg);
      padding: 1.5rem;
      margin-bottom: 1rem;
      box-shadow: var(--shadow-md);
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
    }
    .action-card.primary {
      background: linear-gradient(135deg, var(--accent-light) 0%, var(--accent) 100%);
      color: #fff;
      border-color: transparent;
    }
    .action-card .icon {
      width: 48px;
      height: 48px;
      color: var(--accent-2);
      margin-bottom: 1rem;
    }
    .action-card.primary .icon { color: #fff; }
    .action-card .title { font-size: 1.2rem; font-weight: 800; margin: 0 0 0.5rem; }
    .action-card.primary .title { color: #fff; }
    .action-card .description { font-size: 0.9rem; color: var(--ink-2); margin: 0 0 1.5rem; max-width: 400px; }
    .action-card.primary .description { color: rgba(255,255,255,0.8); }
    .action-card .actions { display: flex; gap: 1rem; justify-content: center; }
    .review-details-list { margin-top: 1rem; border-top: 1px solid var(--line); padding-top: 1rem; }
    .review-detail-item {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.75rem;
      border-radius: var(--radius-md);
    }
    .review-detail-item:hover { background-color: var(--accent-soft); }
    .review-detail-item .timing-tag {
      background-color: var(--accent-2);
      color: #fff;
      font-size: 0.75rem;
      padding: 0.2rem 0.5rem;
      border-radius: 999px;
      font-weight: 700;
      flex-shrink: 0;
    }

    /* ===== 自己評価ボタンのスタイル（修正箇所） ===== */
    .selfbtn.active {
      color: #fff !important;
      transform: translateY(-2px);
      box-shadow: var(--shadow-md);
    }
    .selfbtn[data-tag="perfect"].active { background: #27ae60 !important; border-color: #27ae60 !important; }
    .selfbtn[data-tag="unsure"].active { background: #f39c12 !important; border-color: #f39c12 !important; }
    .selfbtn[data-tag="fail"].active { background: #c0392b !important; border-color: #c0392b !important; }

    /* ===== ホーム画面のレイアウト ===== */
    .page-header { margin-bottom: 1.5rem; }
    .home-dashboard-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-rows: auto 1fr;
      gap: 1.5rem;
      height: calc(100vh - 150px); 
      min-height: 550px;
    }
    .home-dashboard-grid .card { margin-top: 0; }
    .home-dashboard-grid .card:nth-child(1) { grid-column: 1 / 2; grid-row: 1 / 2; }
    .home-dashboard-grid .card:nth-child(2) { grid-column: 1 / 2; grid-row: 2 / 3; }
    .home-dashboard-grid .card-chart {
      grid-column: 2 / 3;
      grid-row: 1 / 3;
      display: flex;
      flex-direction: column;
    }
    .card-chart .chart-container {
      flex-grow: 1;
      position: relative;
      min-height: 300px;
    }
    
    @media(max-width: 999px){
      .home-dashboard-grid {
        display: flex;
        flex-direction: column;
        height: auto;
      }
      .container, main, #app, .page { padding: 1rem; }
    }
  
  .problem-block{background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:12px; margin-bottom:8px;}
  .problem-title{font-size:1.25rem; line-height:1.6; margin:.25rem 0 0;}
</style>
  <script>
    // Optional: disable SW if ?nosw in URL
    (function(){
      if (location.search.includes('nosw')) {
        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.getRegistrations().then(rs => rs.forEach(r => r.unregister()));
        }
        console.log('[SW] Disabled via ?nosw');
      } else if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./sw.js').catch(err=>console.warn('SW register failed', err));
        });
      }
    })();
  
    /* ===== Input Mode (full/cloze) & Cloze helpers ===== */
    function getInputMode(){
      try{
        if (typeof config!=='undefined' && config && config.inputMode) return config.inputMode;
      }catch(_){}
      try{
        const v = localStorage.getItem('rt_inputMode');
        return (v==='cloze' ? 'cloze' : 'full');
      }catch(_){}
      return 'full';
    }
    function setInputMode(m){
      const mode = (m==='cloze') ? 'cloze' : 'full';
      try{ config.inputMode = mode; }catch(_){}
      try{ localStorage.setItem('rt_inputMode', mode); }catch(_){}
      try{ if (typeof saveConfig==='function') saveConfig(); }catch(_){}
      try{ updateInputModeUI(); }catch(_){}
      try{ render(); }catch(_){}
    }
    window.__setInputMode = setInputMode;

    function updateInputModeUI(){
      try{
        const fulls = document.querySelectorAll('.btn-mode-full');
        const clozes = document.querySelectorAll('.btn-mode-cloze');
        const mode = getInputMode();
        fulls.forEach(el => el.classList.toggle('active', mode === 'full'));
        clozes.forEach(el => el.classList.toggle('active', mode === 'cloze'));
      }catch(_){}
    }
    window.addEventListener('load', ()=>{
      try{
        if (!config.inputMode){
          const v = localStorage.getItem('rt_inputMode');
          if (v) config.inputMode = (v==='cloze'?'cloze':'full');
        }
      }catch(_){}
      try{ updateInputModeUI(); }catch(_){}
    });

    function buildClozeNumbered(text, keywords){
      if (!text || !Array.isArray(keywords) || !keywords.length) return null;
      let out = text;
      const pairs = keywords.map((kw, i)=>({kw: String(kw||''), n: i+1})).filter(x=>x.kw.length>0)
                           .sort((a,b)=> b.kw.length - a.kw.length);
      for (const {kw, n} of pairs){
        const esc = kw.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        out = out.replace(new RegExp(esc, 'g'), `<span class="cloze-slot" data-slot="${n}" id="slot-${n}">［${n}］</span>`);
      }
      return out!==text ? out : null;
    }
  </script>
</head>

<body>
<aside id="rail" aria-label="メインナビ">
  <div class="logo">
    <svg class="logo-icon" width="32" height="32" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path d="M12 2L2 7L12 12L22 7L12 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M2 17L12 22L22 17" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-opacity="0.6"/>
      <path d="M2 12L12 17L22 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-opacity="0.8"/>
    </svg>
    <span class="logo-text">論証タイピング</span>
  </div>
  <div class="nav">
    <button data-nav="home"><i class="lucide" data-lucide="home"></i>ホーム</button>
    <button data-nav="subjects"><i class="lucide" data-lucide="book-copy"></i>科目</button>
    <button data-nav="review"><i class="lucide" data-lucide="sparkles"></i>復習</button>
    <button data-nav="add"><i class="lucide" data-lucide="plus-circle"></i>追加</button>
    <button data-nav="search"><i class="lucide" data-lucide="search"></i>検索</button>
    <button data-nav="settings"><i class="lucide" data-lucide="settings"></i>設定</button>
    <button data-nav="exit"><i class="lucide" data-lucide="log-out"></i>終了</button>
  </div>
  <div class="spacer"></div>
  <div class="mode">
    <small>入力モード</small>
    <div class="seg">
      <button id="rail-mode-full" class="btn-mode-full">全文</button>
      <button id="rail-mode-cloze" class="btn-mode-cloze">穴埋め</button>
    </div>
  </div>
</aside>

<header id="mobile-header">
  <nav id="tabbar" aria-label="タブバー">
    <div class="item" data-nav="home"><i class="lucide" data-lucide="home"></i><button>ホーム</button></div>
    <div class="item" data-nav="subjects"><i class="lucide" data-lucide="book-copy"></i><button>科目</button></div>
    <div class="item" data-nav="review"><i class="lucide" data-lucide="sparkles"></i><button>復習</button></div>
    <div class="item" data-nav="add"><i class="lucide" data-lucide="plus-circle"></i><button>追加</button></div>
    <div class="item" data-nav="search"><i class="lucide" data-lucide="search"></i><button>検索</button></div>
    <div class="item" data-nav="settings"><i class="lucide" data-lucide="settings"></i><button>設定</button></div>
    <div class="item" data-nav="exit"><i class="lucide" data-lucide="log-out"></i><button>終了</button></div>
  </nav>
  <div class="mode-switcher-mobile">
    <small>入力モード</small>
    <div class="seg">
      <button class="btn-mode-full">全文</button>
      <button class="btn-mode-cloze">穴埋め</button>
    </div>
  </div>
</header>

<main id="app"></main>

<div id="sys-banner" class="banner hidden"></div>
<div id="modal-root"></div>
<div id="errlayer"><div id="errbox"><h3>エラーが発生しました</h3><pre id="errtext"></pre><div class="section"><button onclick="document.getElementById('errlayer').style.display='none'">閉じる</button></div></div></div>
<div id="toast-container"></div>

<script>
const app = (()=>{
  // ===== Debug overlay =====
  function showError(msg){
    try{
      const txt = (msg && msg.stack) ? msg.stack : (typeof msg==='string' ? msg : JSON.stringify(msg));
      document.getElementById('errtext').textContent = txt;
      document.getElementById('errlayer').style.display = 'flex';
      console.error('[FATAL]', msg);
    }catch(e){ console.error('Error while showing error', e, msg); }
  }
  window.addEventListener('error', e => showError(e.error || e.message));
  window.addEventListener('unhandledrejection', e => showError(e.reason || e));

  const UA = navigator.userAgent || "";
  const IS_IPHONE = /iPhone|iPod/.test(UA) && "ontouchend" in document;
  if (IS_IPHONE) document.documentElement.classList.add('iphone');

  const CORE_SUBJECTS = ["憲法", "民法", "刑法", "商法", "民訴法", "刑訴法", "行政法"];
  const ELECTIVE_SUBJECTS = ["労働法","倒産法","知的財産法","租税法","国際私法","国際公法","経済法","環境法"];
  const ELECTIVE_GROUP = "__ELECTIVE__";
  const IMPORTANCES = ["★重要","★中程度","★低め"];
  const KEY_SPLIT = /[,\u3001\uFF0C\u3002\uFF0E]+/;

  const subjectLabel = (s)=> s===ELECTIVE_GROUP ? "選択科目" : s;
  function importanceLabel(v){
    if (v === "★重要") return "⚫︎ 重要";
    if (v === "★中程度") return "◆ 普通";
    if (v === "★低め") return "▲ 低い";
    return v;
  }

  const VKEYS = ["lawStudyProblemsCache_v91ad8","lawStudyProblemsCache_v91ad7","lawStudyProblemsCache_v91ad6"];
  const CACHE_KEY = VKEYS[0];
  const UI_KEYS = ["lawStudyUI_v91ad8","lawStudyUI_v91ad7","lawStudyUI_v91ad6"];
  const UI_KEY = UI_KEYS[0];

  const CFG_STABLE_KEY = "lawStudyCfg";
  const CFG_OLD_KEYS = ["lawStudyCfg_v91x","lawStudyCfg_v91w"];
  const config = loadConfig();
  function loadConfig(){
    let c = null;
    try{ c = JSON.parse(localStorage.getItem(CFG_STABLE_KEY)); }catch{}
    if (!c){
      for (const k of CFG_OLD_KEYS){
        try{ const v = JSON.parse(localStorage.getItem(k)); if (v){ c=v; break; } }catch{}
      }
    }
    if (!c) c = {
      autoLocalSave:true, autoRestore:true, fileAutoSave:true,
      iosShowImportAtBoot:true, iosShowExportGuide:true,
      mixRatio: {unsure:5, fail:3, other:2},
      enableCommandPalette: true
    };
    ["autoLocalSave","autoRestore","fileAutoSave","iosShowImportAtBoot","iosShowExportGuide","mixRatio","enableCommandPalette"].forEach(k=>{
      if (typeof c[k]==="undefined") c[k]= (k==="mixRatio"?{unsure:5,fail:3,other:2} : true);
    });
    return c;
  }
  function saveConfig(){ localStorage.setItem(CFG_STABLE_KEY, JSON.stringify(config)); }

  // ====== 日付（ローカル基準） ======
  const ymdLocal = (d=new Date())=>{
    const t=new Date(d); t.setHours(0,0,0,0);
    const y=t.getFullYear(), m=t.getMonth()+1, dd=t.getDate();
    return `${y}-${String(m).padStart(2,'0')}-${String(dd).padStart(2,'0')}`;
  };
  const addDaysLocal = (days)=>{
    const t=new Date(); t.setHours(0,0,0,0); t.setDate(t.getDate()+days);
    return ymdLocal(t);
  };
  const parseYMD = (s)=>{ const [y,m,d]=s.split('-').map(Number); const dt=new Date(y,m-1,d); dt.setHours(0,0,0,0); return dt; };
  const daysBetweenLocal = (ymdA, ymdB)=> Math.round((parseYMD(ymdA)-parseYMD(ymdB))/(1000*60*60*24));

  // ====== 日次カウント ======
  const DAILY_KEY = "lawStudyDaily_v1";
  function getDailyMap(){
    try{ return JSON.parse(localStorage.getItem(DAILY_KEY)) || {}; }catch{ return {}; }
  }
  function setDailyMap(m){ localStorage.setItem(DAILY_KEY, JSON.stringify(m)); }
  function addDailyAnswered(n=1){
    const t = ymdLocal(new Date());
    const m = getDailyMap(); m[t] = (m[t]||0) + n; setDailyMap(m);
  }
  function calcStreak(){
    const m = getDailyMap();
    let streak = 0;
    for (let back=0; ; back++){
      const d = new Date(); d.setDate(d.getDate()-back);
      const ymd = ymdLocal(d);
      if ((m[ymd]||0) > 0) streak++;
      else break;
    }
    return streak;
  }
  function todayCount(){ const m=getDailyMap(); const t=ymdLocal(new Date()); return m[t]||0; }

  // ====== ローカル保存 ======
  function saveLocal(problems, sessions){
    if (!config.autoLocalSave) return;
    const payload = { updatedAt: new Date().toISOString(), problems, sessions: sessionsState.logs };
    localStorage.setItem(CACHE_KEY, JSON.stringify(payload));
    updateNavBadges();
  }
  function loadLocal(){
    for (const key of VKEYS){
      try{
        const s = localStorage.getItem(key);
        if (!s) continue;
        const obj = JSON.parse(s);
        if (obj && Array.isArray(obj.problems)) return obj;
      }catch{}
    }
    return null;
  }
  function clearLocal(){ localStorage.removeItem(CACHE_KEY); updateNavBadges(); }

  function saveUI(ui){ localStorage.setItem(UI_KEY, JSON.stringify(ui)); }
  function loadUI(){
    for (const k of UI_KEYS){
      try{
        const s = localStorage.getItem(k);
        if (s) return JSON.parse(s);
      }catch{}
    }
    return {};
  }

  // ====== IDB（ファイルハンドル保存） ======
  const DB_NAME = 'lawStudyFS';
  const STORE = 'handles';
  function idbOpen(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = () => { req.result.createObjectStore(STORE); };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  async function idbSet(key, val){
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, 'readwrite');
      tx.objectStore(STORE).put(val, key);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }
  async function idbGet(key){
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, 'readonly');
      const req = tx.objectStore(STORE).get(key);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }
  async function idbDelete(key){
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE, 'readwrite');
      tx.objectStore(STORE).delete(key);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  let fileHandle = null;
  let fileSaveTimer = null;
  const supportsFS = !!(window.showOpenFilePicker || window.showSaveFilePicker);

  function banner(html){ const el=document.getElementById('sys-banner'); el.innerHTML=html; el.classList.remove('hidden'); }
  function hideBanner(){ document.getElementById('sys-banner').classList.add('hidden'); }

  async function pickFile(){
    if (!supportsFS) { showToast("このブラウザはファイル連携をサポートしていません。"); return; }
    try{
      const [handle] = await window.showOpenFilePicker({
        types: [{description:"JSON", accept: {"application/json": [".json"]}}],
        excludeAcceptAllOption: true, multiple: false
      });
      let perm = await handle.queryPermission({mode:"readwrite"});
      if (perm !== "granted") perm = await handle.requestPermission({mode:"readwrite"});
      if (perm !== "granted") { showToast("書き込み権限がありません。", "error"); return; }
      fileHandle = handle;
      await idbSet('problems', handle);
      await saveToFile();
      showToast('iCloud Drive のファイルに接続しました。');
      render();
    }catch(e){ console.warn(e); }
  }

  async function tryRestoreFileHandle(autoPrompt=true){
    if (!supportsFS) return false;
    try{
      const handle = await idbGet('problems');
      if (!handle) return false;
      let perm = await handle.queryPermission({mode:"readwrite"});
      if (perm === "prompt" && autoPrompt){
        perm = await handle.requestPermission({mode:"readwrite"});
      }
      if (perm === "granted"){
        fileHandle = handle;
        const ok = await loadFromFile();
        if (ok){
          showToast('同期ファイルを読み込みました。');
          return true;
        }
      }
    }catch(e){ console.warn("restore handle failed:", e); }
    return false;
  }

  async function loadFromFile(){
    if (!fileHandle) return false;
    try{
      const file = await fileHandle.getFile();
      const text = await file.text();
      const data = text ? JSON.parse(text) : [];
      if (!Array.isArray(data)) throw new Error("JSONは配列ではありません（v9互換）");
      sanitizeProblems(data);
      state.problems = data;
      reindex();
      saveLocal(state.problems, sessionsState.logs);
      render();
      return true;
    }catch(e){
      console.warn("ファイル読込失敗:", e);
      showToast('problems.json の読み込みに失敗しました: '+ e.message, 'error');
      return false;
    }
  }

  async function saveToFile(){
    if (!fileHandle) return;
    try{
      const writable = await fileHandle.createWritable();
      await writable.write(JSON.stringify(state.problems, null, 2));
      await writable.close();
    }catch(e){ console.warn("ファイル保存に失敗:", e); }
  }
  function scheduleFileSave(){
    if (!fileHandle) return;
    if (fileSaveTimer) clearTimeout(fileSaveTimer);
    fileSaveTimer = setTimeout(saveToFile, 200);
  }

  function sanitizeProblems(arr){
    if (!Array.isArray(arr)) throw new Error("不正なデータ形式");
    arr.forEach(p => {
      if (!Array.isArray(p.history)) p.history = [];
      if (!Array.isArray(p.reviews)) p.reviews = [];
      if (!p.example) p.example = "";
      if (!p.note) p.note = "";
      if (!p.subject) p.subject = "未分類";
      if (!p.importance) p.importance = "★中程度";
      if (!p.selfStats) p.selfStats = {perfect:0,unsure:0,fail:0};
      if (typeof p.weakPoints !== 'number') p.weakPoints = 0;
      if (typeof p.topic === "undefined") p.topic = "";
      if (typeof p.subtopic === "undefined") p.subtopic = "";
    });
  }

  // ====== 監査ログ ======
  const sessionsState = {
    current: null,
    logs: []
  };
  function startSession(ids, random, mode){
    endSession();
    sessionsState.current = {
      id: Date.now()+Math.floor(Math.random()*1000),
      startAt: new Date().toISOString(),
      endAt: null,
      context: {subject: state.currentSubject, topic: state.currentTopic, subtopic: state.currentSubtopic, random: !!random, mode: mode||null},
      planned: ids.length,
      answered: 0,
      scoreCount: {ok:0, good:0, low:0, bad:0}
    };
    saveLocal(state.problems, sessionsState.logs);
  }
  function bumpSessionOnScore(scoreChar){
    if (!sessionsState.current) return;
    sessionsState.current.answered++;
    if (scoreChar==="◎") sessionsState.current.scoreCount.ok++;
    else if (scoreChar==="○") sessionsState.current.scoreCount.good++;
    else if (scoreChar==="△") sessionsState.current.scoreCount.low++;
    else sessionsState.current.scoreCount.bad++;
    saveLocal(state.problems, sessionsState.logs);
  }
  function endSession(){
    if (!sessionsState.current) return;
    const s = sessionsState.current;
    s.endAt = new Date().toISOString();
    try{
      s.durationSec = Math.max(0, Math.round((new Date(s.endAt)-new Date(s.startAt))/1000));
    }catch{ s.durationSec = null; }
    sessionsState.logs.push(s);
    sessionsState.current = null;
    saveLocal(state.problems, sessionsState.logs);
  }
  function exportSessionCSV(){
    const rows = [["id","startAt","endAt","durationSec","subject","topic","subtopic","random","planned","answered","ok","good","low","bad"]];
    sessionsState.logs.forEach(l=>{
      rows.push([l.id,l.startAt,l.endAt,l.durationSec,
        l.context?.subject||"", l.context?.topic||"", l.context?.subtopic||"", l.context?.random?1:0,
        l.planned, l.answered, l.scoreCount.ok, l.scoreCount.good, l.scoreCount.low, l.scoreCount.bad]);
    });
    const csv = rows.map(r=> r.map(x=> `"${String(x).replace(/"/g,'""')}"`).join(",")).join("\n");
    const blob = new Blob([csv], {type:"text/csv"});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = "study-sessions.csv";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  const state = {
    view: 'home',
    problems: [],
    currentSubject: null,
    currentTopic: 'all',
    currentSubtopic: 'all',
    currentImportance: 'all',
    currentSelf: 'all',
    currentProblemId: null,
    reviewQueue: null,
    reviewTab: 'today', // 'today', 'weak', 'custom'
    reviewTodayListVisible: false,
    timerStart: null,
    timerTick: null
  };

  // ====== インデックス ======
  let indexCache = null;
  function reindex(){
    const subjects = new Map();
    const topics = new Map();
    const subtopics = new Map();
    state.problems.forEach(p=>{
      const subj = (p.subject===ELECTIVE_GROUP || ELECTIVE_SUBJECTS.includes(p.subject)) ? (p.subject===ELECTIVE_GROUP?ELECTIVE_GROUP:p.subject) : p.subject;
      if (!subjects.has(subj)) subjects.set(subj, []);
      subjects.get(subj).push(p.id);
      const t = (p.topic||"");
      const st = (p.subtopic||"");
      if (!topics.has(subj)) topics.set(subj, new Map());
      if (!topics.get(subj).has(t)) topics.get(subj).set(t, []);
      topics.get(subj).get(t).push(p.id);
      if (!subtopics.has(subj)) subtopics.set(subj, new Map());
      if (!subtopics.get(subj).has(t)) subtopics.get(subj).set(t, new Map());
      if (!subtopics.get(subj).get(t).has(st)) subtopics.get(subj).get(t).set(st, []);
      subtopics.get(subj).get(t).get(st).push(p.id);
    });
    indexCache = {subjects, topics, subtopics};
  }
  function idsBySubject(s){ if (!indexCache) reindex(); if (s===ELECTIVE_GROUP){ const ids=new Set(indexCache.subjects.get(ELECTIVE_GROUP)||[]); ELECTIVE_SUBJECTS.forEach(x=> (indexCache.subjects.get(x)||[]).forEach(id=>ids.add(id))); return [...ids]; } return (indexCache.subjects.get(s)||[]).slice(); }
  function idsByTopic(s,t){ if (!indexCache) reindex(); return ((indexCache.topics.get(s)||new Map()).get(t||"")||[]).slice(); }
  function idsBySubtopic(s,t,st){ if (!indexCache) reindex(); return (((indexCache.subtopics.get(s)||new Map()).get(t||"")||new Map()).get(st||"")||[]).slice(); }
  
  function topicsForSubject(subj){
    const list = idsBySubject(subj)
      .map(id => idToProb(id))
      .filter(Boolean)
      .map(p => (p.topic||"").trim())
      .filter(t=>t);
    return Array.from(new Set(list)).sort((a,b)=> a.localeCompare(b,'ja'));
  }
  function subtopicsFor(subj, topic){
    const list = idsByTopic(subj, topic)
      .map(id => idToProb(id))
      .filter(Boolean)
      .map(p => (p.subtopic||"").trim())
      .filter(t=>t);
    return Array.from(new Set(list)).sort((a,b)=> a.localeCompare(b,'ja'));
  }

  const $app = document.getElementById('app');

  function setActive(view){
    state.view = view;
    if (view !== 'quiz') { state.reviewQueue = null; endSession(); stopTimer(); }
    if (view === 'review') { state.reviewTab = 'today'; }
    render();
    
    document.querySelectorAll('#rail .nav button, #tabbar .item').forEach(n => n.classList.remove('active'));
    document.querySelectorAll(`[data-nav="${view}"]`).forEach(el => {
      // For rail buttons, the element itself gets 'active'. For tabbar, it's the parent item.
      if (el.matches('#rail .nav button')) {
        el.classList.add('active');
      } else if (el.matches('#tabbar .item')) {
        el.classList.add('active');
      }
    });

    saveUI({
      currentSubject: state.currentSubject,
      currentTopic: state.currentTopic,
      currentSubtopic: state.currentSubtopic,
      currentImportance: state.currentImportance,
      currentProblemId: state.currentProblemId,
      currentSelf: state.currentSelf
    });
    updateNavBadges();
  }

  function lastAnswerYmdLocal(p){
    if (!Array.isArray(p.history) || p.history.length===0) return null;
    let last = null;
    for (let i=0;i<p.history.length;i++){
      const h = p.history[i];
      if (h && h.date){
        const ymd = ymdLocal(new Date(h.date));
        if (!last || ymd > last) last = ymd;
      }
    }
    return last;
  }

  function getNextReviewDate(p) {
    if (!p || !Array.isArray(p.reviews) || p.reviews.length === 0) return null;
    // Dates are 'YYYY-MM-DD' strings, so alphabetical sort is chronological sort.
    return p.reviews.slice().sort()[0];
  }

  function todayStr(){ return ymdLocal(new Date()); }
  function escapeHtml(s){ return (s||"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;"); }
  function idToProb(id){ return state.problems.find(p=>p.id===id); }
  function shuffle(arr){ const a=arr.slice(); for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }

  function filtered(){
    let arr = problemsBySubjectFiltered(state.currentSubject);
    if (state.currentTopic !== 'all'){ arr = arr.filter(p => (p.topic||"") === state.currentTopic); }
    if (state.currentSubtopic !== 'all'){ arr = arr.filter(p => (p.subtopic||"") === state.currentSubtopic); }
    return arr;
  }

// === Self-tag helpers =========================
// p.history の一番新しい自己評価タグを返す。
// フォーマットの揺れに強く、history優先で探し、無ければ直下/selfStatsから推定。
function latestSelfTag(p){
  if (!p) return null;

  // 1) history から最新を拾う（末尾優先）
  const hist = Array.isArray(p.history) ? p.history : [];
  for (let i = hist.length - 1; i >= 0; i--){
    const h = hist[i] || {};
    if (h.selfTag) return h.selfTag;   // 推奨キー
    if (h.tag)     return h.tag;       // 旧/別表記
    if (h.self)    return h.self;      // さらに旧/別表記
  }

  // 2) 直下フィールド
  if (p.lastSelfTag) return p.lastSelfTag;
  if (p.selfTag)     return p.selfTag;
  if (p.self)        return p.self;

  // 3) selfStats から推定（最多のもの）
  if (p.selfStats){
    let best = null, max = -1;
    for (const [k, v] of Object.entries(p.selfStats)){
      const n = Number(v) || 0;
      if (n > max){ max = n; best = k; }
    }
    if (best) return best; // 'perfect' | 'unsure' | 'fail' など
  }
  // 4) 未評価
  return null;
}


  function meetsFilters(p){
    const impOk = (state.currentImportance==='all') || (p.importance===state.currentImportance);
    const tag = latestSelfTag(p);
    const selfOk = (state.currentSelf==='all') || (tag===state.currentSelf);
    return impOk && selfOk;
  }
  function problemsBySubjectFiltered(subj){
    const ids = idsBySubject(subj);
    return ids.map(id=>idToProb(id)).filter(Boolean).filter(meetsFilters);
  }

  // ====== 復習バッジ ======
  function getDueTodayIds(){
    const t = todayStr();
    const dueToday = new Set();
    state.problems.forEach(p => {
      const revs = (p.reviews||[]).filter(d => d <= t);
      if (revs.length) dueToday.add(p.id);
    });
    if (dueToday.size===0){
      const intervals = [1,3,7,14,30];
      state.problems.forEach(p => {
        const last = lastAnswerYmdLocal(p);
        if (!last) return;
        const d = daysBetweenLocal(t, last);
        if (intervals.includes(d) || d > intervals[intervals.length-1]) dueToday.add(p.id);
      });
    }
    return Array.from(dueToday);
  }
  function getDueTodayCount(){ return getDueTodayIds().length; }
  function updateNavBadges(){
    const btn = document.querySelector('[data-nav="review"]');
    if (!btn) return;
    const n = getDueTodayCount();
    
    // Find the right element to add the badge to
    const targetElement = btn.matches('#rail .nav button') ? btn : btn.querySelector('button');
    if (!targetElement) return;

    const existingBadge = btn.querySelector('.badge');
    if(existingBadge) existingBadge.remove();

    if (n > 0){
      const shown = (n > 99 ? "99+" : String(n));
      targetElement.insertAdjacentHTML('beforeend', ` <span class="badge" title="${n}件">${shown}</span>`);
    }
  }

  // ====== 弱点ドリル ======
  function buildWeakDrillWeighted(allIds, ratio, takeN, doShuffle){
    const buckets = {unsure:[], fail:[], other:[]};
    allIds.forEach(id=>{
      const p = idToProb(id);
      const last = latestSelfTag(p);
      const weight = Math.max(0, Number(p.weakPoints||0));
      const rec = {id, weight};
      if (last==='unsure') buckets.unsure.push(rec);
      else if (last==='fail') buckets.fail.push(rec);
      else buckets.other.push(rec);
    });
    buckets.unsure.sort((a,b)=> b.weight - a.weight);
    buckets.fail.sort((a,b)=> b.weight - a.weight);
    buckets.other.sort((a,b)=> b.weight - a.weight);

    const N = Math.max(1, Number(takeN||20));
    const result = [];
    let iu=0, ifa=0, io=0;
    while (result.length < N && (iu<buckets.unsure.length || ifa<buckets.fail.length || io<buckets.other.length)){
      for(let i=0; i<ratio.unsure && result.length<N && iu<buckets.unsure.length; i++){ result.push(buckets.unsure[iu++].id); }
      for(let i=0; i<ratio.fail   && result.length<N && ifa<buckets.fail.length;   i++){ result.push(buckets.fail[ifa++].id); }
      for(let i=0; i<ratio.other  && result.length<N && io<buckets.other.length;  i++){ result.push(buckets.other[io++].id); }
      if (iu>=buckets.unsure.length && ifa>=buckets.fail.length && io<buckets.other.length){
        while (io<buckets.other.length && result.length<N){ result.push(buckets.other[io++].id); }
      }
    }
    if (doShuffle){
      for(let i=result.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [result[i],result[j]]=[result[j],result[i]]; }
    }
    return result;
  }
  
  function render(){
    let content = '';
    try{
      if (state.view === 'home')     content = renderHome();
      else if (state.view === 'search')   content = renderSearch();
      else if (state.view === 'subjects') content = renderSubjects();
      else if (state.view === 'topics')   content = renderTopics();
      else if (state.view === 'subtopics')content = renderSubtopics();
      else if (state.view === 'list')     content = renderList();
      else if (state.view === 'quiz')     content = renderQuiz();
      else if (state.view === 'add')      content = renderAdd();
      else if (state.view === 'review')   content = renderReview();
      else if (state.view === 'edit')     content = renderEdit();
      else if (state.view === 'settings') content = renderSettings();
    } catch(e){ 
      showError(e); 
      return;
    }

    $app.innerHTML = `<div class="page-container">${content}</div>`;
    
    // After rendering any view, initialize icons
    if (window.lucide) {
      lucide.createIcons();
    }

    // Special handling for chart rendering
    if (state.view === 'home') {
      renderChart();
    }
  }

  function calculateRadarChartData() {
    const subjects = [...CORE_SUBJECTS, ELECTIVE_GROUP];
    const labels = subjects.map(s => subjectLabel(s));
    const totalAnswersData = [];
    const correctRateData = [];

    subjects.forEach(subjectName => {
        const problemIds = idsBySubject(subjectName);
        const problems = problemIds.map(id => idToProb(id)).filter(Boolean);

        let totalAnswers = 0;
        let correctAnswers = 0;

        problems.forEach(p => {
            if (p.history && p.history.length > 0) {
                totalAnswers += p.history.length;
                p.history.forEach(h => {
                    if (h.score === '◎' || h.score === '○') {
                        correctAnswers++;
                    }
                });
            }
        });

        totalAnswersData.push(totalAnswers);
        const rate = totalAnswers > 0 ? (correctAnswers / totalAnswers) * 100 : 0;
        correctRateData.push(rate);
    });

    const maxAnswers = Math.max(...totalAnswersData);
    const normalizedAnswersData = maxAnswers > 0 ? totalAnswersData.map(d => (d / maxAnswers) * 100) : totalAnswersData.map(() => 0);

    return {
        labels,
        datasets: [
            {
                label: '総回答数',
                data: normalizedAnswersData,
                originalData: totalAnswersData,
                backgroundColor: 'rgba(13, 27, 50, 0.2)',
                borderColor: 'rgba(13, 27, 50, 1)',
                pointBackgroundColor: 'rgba(13, 27, 50, 1)',
                borderWidth: 2,
            },
            {
                label: '正答率',
                data: correctRateData,
                originalData: correctRateData,
                backgroundColor: 'rgba(197, 152, 75, 0.2)',
                borderColor: 'rgba(197, 152, 75, 1)',
                pointBackgroundColor: 'rgba(197, 152, 75, 1)',
                borderWidth: 2,
            }
        ]
    };
  }

  function getAnsweredDueTodayCount() {
    const today = todayStr();
    const dueIds = getDueTodayIds();
    let answeredCount = 0;
    dueIds.forEach(id => {
        const p = idToProb(id);
        if (p && p.history) {
            const answeredToday = p.history.some(h => ymdLocal(new Date(h.date)) === today);
            if (answeredToday) {
                answeredCount++;
            }
        }
    });
    return answeredCount;
  }

  function calculateGlobalStats() {
    const totalProblems = state.problems.length;
    const answeredProblems = state.problems.filter(p => p.history && p.history.length > 0).length;
    
    let totalAnswers = 0;
    let correctAnswers = 0;
    state.problems.forEach(p => {
      if (p.history && p.history.length > 0) {
        totalAnswers += p.history.length;
        p.history.forEach(h => {
          if (h.score === '◎' || h.score === '○') {
            correctAnswers++;
          }
        });
      }
    });

    const correctRate = totalAnswers > 0 ? (correctAnswers / totalAnswers) * 100 : 0;

    return { totalProblems, answeredProblems, totalAnswers, correctRate };
  }

  let radarChart = null;
  function renderHome() {
    const dueCount = getDueTodayCount();
    const answeredToday = todayCount();
    const streak = calcStreak();
    const globalStats = calculateGlobalStats();
    
    const dailyStatsHtml = `
      <h3>今日の進捗</h3>
      <div class="home-grid section">
        <div class="stat-card animated-list-item" style="animation-delay: 0ms;">
          <div class="value">${dueCount}<span class="unit">件</span></div>
          <div class="label">今日の復習</div>
        </div>
        <div class="stat-card animated-list-item" style="animation-delay: 100ms;">
          <div class="value">${answeredToday}<span class="unit">件</span></div>
          <div class="label">本日の解答数</div>
        </div>
        <div class="stat-card animated-list-item" style="animation-delay: 200ms;">
          <div class="value">${streak}<span class="unit">日</span></div>
          <div class="label">継続日数</div>
        </div>
      </div>
    `;
    
    const globalStatsHtml = `
      <h3>全体の進捗</h3>
      <div class="home-grid section">
         <div class="stat-card animated-list-item" style="animation-delay: 300ms;">
          <div class="value">${globalStats.answeredProblems}<span class="unit">/ ${globalStats.totalProblems} 問</span></div>
          <div class="label">解答済み問題</div>
        </div>
        <div class="stat-card animated-list-item" style="animation-delay: 400ms;">
          <div class="value">${globalStats.totalAnswers}<span class="unit">回</span></div>
          <div class="label">総解答数</div>
        </div>
        <div class="stat-card animated-list-item" style="animation-delay: 500ms;">
          <div class="value">${globalStats.correctRate.toFixed(1)}<span class="unit">%</span></div>
          <div class="label">総正解率</div>
        </div>
      </div>
    `;

    return `
      <div class="page-header">
        <h2>ホーム</h2>
      </div>
      <div class="home-dashboard-grid">
        <div class="card animated-list-item" style="animation-delay: 0ms;">
          ${dailyStatsHtml}
        </div>
        <div class="card animated-list-item" style="animation-delay: 150ms;">
          ${globalStatsHtml}
        </div>
        <div class="card card-chart animated-list-item" style="animation-delay: 300ms;">
          <h3>学習バランス</h3>
          <div class="chart-container">
            <canvas id="radarChart"></canvas>
          </div>
        </div>
      </div>
    `;
  }

  function renderChart() {
    const radarData = calculateRadarChartData();
    const ctx = document.getElementById('radarChart');
    if (!ctx) return;
    if (radarChart) {
        radarChart.destroy();
    }
    radarChart = new Chart(ctx, {
        type: 'radar',
        data: radarData,
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                r: {
                    angleLines: { display: true, color: 'rgba(0,0,0,0.1)' },
                    suggestedMin: 0,
                    suggestedMax: 100,
                    pointLabels: { font: { size: 12, weight: 'bold', family: '"SF Pro Text", sans-serif' } },
                    ticks: { backdropColor: 'transparent', color: 'rgba(0,0,0,0.5)' }
                }
            },
            plugins: {
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) { label += ': '; }
                            if (context.dataset.label.includes('総回答数')) {
                                label += context.dataset.originalData[context.dataIndex] + '回';
                            } else {
                                label += parseFloat(context.raw).toFixed(1) + '%';
                            }
                            return label;
                        }
                    }
                },
                legend: {
                    position: 'bottom',
                    labels: {
                        font: { family: '"SF Pro Text", sans-serif' }
                    }
                }
            }
        }
    });
  }

  function renderSearch() {
    const html = `
      <div class="card">
        <h2>問題の検索</h2>
        <div class="section">
          <input type="search" id="search-input" placeholder="問題文、分野、小分類で検索...">
        </div>
        <div id="search-results" class="section">
          <p class="muted">検索キーワードを入力してください。</p>
        </div>
      </div>
    `;
    // We need to attach event listeners after rendering
    setTimeout(() => {
        const input = document.getElementById('search-input');
        const resultsContainer = document.getElementById('search-results');
        if (input) {
            input.addEventListener('input', () => {
              const query = input.value.toLowerCase().trim();
              if (query.length < 1) {
                resultsContainer.innerHTML = '<p class="muted">検索キーワードを入力してください。</p>';
                return;
              }

              const results = state.problems.filter(p => 
                (p.question || '').toLowerCase().includes(query) ||
                (p.topic || '').toLowerCase().includes(query) ||
                (p.subtopic || '').toLowerCase().includes(query)
              );

              if (results.length === 0) {
                resultsContainer.innerHTML = '<p class="muted">該当する問題はありませんでした。</p>';
                return;
              }

              resultsContainer.innerHTML = results.map(p => `
                <div class="list-item">
                  <div class="flex">
                    <div class="space">
                      <strong>${escapeHtml(p.question)}</strong>
                      <div class="muted small">${escapeHtml(subjectLabel(p.subject))} > ${escapeHtml(p.topic)} > ${escapeHtml(p.subtopic)}</div>
                    </div>
                    <button class="ghost" onclick="app.startQuiz(${p.id})">解く</button>
                    <button class="ghost" onclick="app.editProblem(${p.id})">編集</button>
                  </div>
                </div>
              `).join('');
            });
        }
    }, 0);
    return html;
  }

  function filterBarHTML(){
    const impOpts = `
      <option value="all" ${state.currentImportance==='all'?'selected':''}>すべて</option>
      ${IMPORTANCES.map(im=>`<option value="${im}" ${state.currentImportance===im?'selected':''}>${importanceLabel(im)}</option>`).join('')}
    `;
    const selfOpts = `
      <option value="all" ${state.currentSelf==='all'?'selected':''}>すべて</option>
      <option value="perfect" ${state.currentSelf==='perfect'?'selected':''}>できた</option>
      <option value="unsure" ${state.currentSelf==='unsure'?'selected':''}>普通</option>
      <option value="fail" ${state.currentSelf==='fail'?'selected':''}>できない</option>
    `;
    return `
      <div class="section filter-bar">
        <div class="filter-group">
          <div class="filter-item">
            <label class="small">重要度</label>
            <select onchange="app.setImp(this.value)">${impOpts}</select>
          </div>
          <div class="filter-item">
            <label class="small">自己評価</label>
            <select onchange="app.setSelf(this.value)">${selfOpts}</select>
          </div>
          <div class="filter-item">
            <label class="small">件数</label>
            <input type="number" id="count-subject" min="1" step="1" placeholder="（全件）">
          </div>
        </div>
        <div class="filter-actions">
          <button class="ghost" onclick="app.resetFilters()"><i data-lucide="rotate-ccw" style="width:16px; height:16px;"></i>リセット</button>
        </div>
      </div>
    `;
  }
  
  function rawCountBySubject(name){
    const ids = idsBySubject(name);
    return ids.map(id=>idToProb(id)).filter(Boolean).filter(meetsFilters).length;
  }

  function renderSubjects(){
    const coreHtml = CORE_SUBJECTS.map((s, i)=>`
      <div class="list-item animated-list-item" style="animation-delay: ${i * 50}ms; cursor:pointer" onclick="app.selectSubject('${s}')">
        <div class="flex">
          <strong>${s}</strong>
          <span class="pill">${rawCountBySubject(s)} 問</span>
          <div class="space"></div>
          <i data-lucide="chevron-right" class="lucide"></i>
        </div>
      </div>`).join('');

    const electiveHtml = `
      <div class="list-item animated-list-item" style="animation-delay: ${CORE_SUBJECTS.length * 50}ms; cursor:pointer" onclick="app.selectElective()">
        <div class="flex">
          <strong>選択科目</strong>
          <span class="pill">${rawCountBySubject("__ELECTIVE__")} 問</span>
          <div class="space"></div>
          <i data-lucide="chevron-right" class="lucide"></i>
        </div>
      </div>
    `;

    return `
        <h2>科目を選択</h2>
        <div class="section">
          <h3>必修科目</h3>
          <div class="home-grid section">
            ${coreHtml || '<div class="muted">（未登録でも選択できます）</div>'}
          </div>
        </div>
        <div class="section">
          <h3>選択科目</h3>
          <div class="home-grid section">
            ${electiveHtml}
          </div>
        </div>
    `;
  }
  
  function topicCount(subj, topic){ return idsByTopic(subj, topic).map(id=>idToProb(id)).filter(Boolean).filter(meetsFilters).length; }
  function unclassifiedTopicCount(subj){ return idsByTopic(subj, "").map(id=>idToProb(id)).filter(Boolean).filter(meetsFilters).length; }

  function getSubjectCount(){
    const inp = document.getElementById('count-subject');
    if (!inp) return null;
    const v = Math.floor(Number(inp.value||0));
    return (isFinite(v) && v>0) ? v : null;
  }
  function pickWithLimit(ids, n, rnd){
    let arr = ids.slice();
    if (rnd){
      for (let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
    }
    if (n){ return arr.slice(0, n); }
    return arr;
  }

  function renderTopics(){
    const subj = state.currentSubject;
    if (!subj){ setActive('subjects'); return ''; }
    const topics = topicsForSubject(subj);
    const list = topics.filter(t=>t).map((t, i)=>`
      <div class="list-item animated-list-item" style="animation-delay: ${i * 50}ms; cursor:pointer" onclick="app.selectTopic('${t.replace(/'/g,"\\'")}')">
        <div class="flex">
          <strong>${t}</strong>
          <span class="pill">${topicCount(subj, t)} 件</span>
          <div class="space"></div>
          <button class="ghost" onclick="event.stopPropagation();app.startTopic('${t.replace(/'/g,"\\'")}', false)">順番</button>
          <button class="ghost" onclick="event.stopPropagation();app.startTopic('${t.replace(/'/g,"\\'")}', true)">ランダム</button>
        </div>
      </div>
    `).join('');

    const subjectCount = rawCountBySubject(subj);

    return `
        <div class="flex">
          <button class="ghost" onclick="app.setActive('subjects')"><i data-lucide="arrow-left"></i>科目一覧</button>
          <h2 style="margin:0 .5rem">科目：${subjectLabel(subj)}（${subjectCount} 件）</h2>
        </div>
        ${filterBarHTML()}
        <div class="section">
          <div class="list-item">
            <div style="cursor:pointer" onclick="app.selectTopic('all')" class="flex">
              <strong>（この科目の全て）</strong>
              <span class="pill">${subjectCount} 件</span>
              <div class="space"></div>
              <button class="ghost" onclick="event.stopPropagation();app.startSubjectAll(false)">順番</button>
              <button class="ghost" onclick="event.stopPropagation();app.startSubjectAll(true)">ランダム</button>
            </div>
          </div>
        </div>
        <div class="section">
          <h3>分野</h3>
          <div class="home-grid">
            ${list || '<div class="muted">（この条件に一致する分野はありません）</div>'}
          </div>
        </div>
        ${unclassifiedTopicCount(subj)>0 ? `
        <div class="section">
          <h3>未分類の分野</h3>
          <div class="list-item animated-list-item" style="animation-delay: ${topics.length * 50}ms">
            <div style="cursor:pointer" onclick="app.selectTopic('')" class="flex">
              <strong>未分類</strong>
              <span class="pill">${unclassifiedTopicCount(subj)} 件</span>
              <div class="space"></div>
              <button class="ghost" onclick="event.stopPropagation();app.startTopic(\'\', false)">順番</button>
              <button class="ghost" onclick="event.stopPropagation();app.startTopic('', true)">ランダム</button>
            </div>
          </div>
        </div>` : ''}
    `;
  }
  
  function subtopicCount(subj, topic, subtopic){ return idsBySubtopic(subj, topic, subtopic).map(id=>idToProb(id)).filter(Boolean).filter(meetsFilters).length; }
  function unclassifiedSubtopicCount(subj, topic){ return idsBySubtopic(subj, topic, "").map(id=>idToProb(id)).filter(Boolean).filter(meetsFilters).length; }
  
  function renderSubtopics(){
    const subj = state.currentSubject;
    const topic = state.currentTopic;
    if (!subj) { setActive('subjects'); return ''; }
    if (topic==='all'){ setActive('list'); return ''; }

    const subs = subtopicsFor(subj, topic);
    const list = subs.map((st, i)=>`
      <div class="list-item animated-list-item" style="animation-delay: ${i * 50}ms; cursor:pointer" onclick="app.selectSubtopic('${st.replace(/'/g,"\\'")}')">
        <div class="flex">
          <strong>${st}</strong>
          <span class="pill">${subtopicCount(subj, topic, st)} 件</span>
          <div class="space"></div>
          <button class="ghost" onclick="event.stopPropagation();app.startSubtopic('${st.replace(/'/g,"\\'")}', false)">順番</button>
          <button class="ghost" onclick="event.stopPropagation();app.startSubtopic('${st.replace(/'/g,"\\'")}', true)">ランダム</button>
        </div>
      </div>
    `).join('');

    const topicAll = idsByTopic(subj, topic).map(id=>idToProb(id)).filter(Boolean).filter(meetsFilters).length;

    return `
        <div class="flex">
          <button class="ghost" onclick="app.setActive('topics')"><i data-lucide="arrow-left"></i>分野一覧</button>
          <button class="ghost" onclick="app.setActive('subjects')"><i data-lucide="arrow-left"></i>科目一覧</button>
          <h2 style="margin:0 .5rem">科目：${subjectLabel(subj)} / 分野：${topic}（${topicAll} 件）</h2>
        </div>
        <div class="section">
          <div class="list-item">
            <div style="cursor:pointer" onclick="app.selectSubtopic('all')" class="flex">
              <strong>（この分野の全て）</strong>
              <span class="pill">${topicAll} 件</span>
              <div class="space"></div>
              <button class="ghost" onclick="event.stopPropagation();app.startTopicAll(false)">順番</button>
              <button class="ghost" onclick="event.stopPropagation();app.startTopicAll(true)">ランダム</button>
            </div>
          </div>
        </div>
        <div class="section">
          <h3>小分類</h3>
          <div class="home-grid">
            ${list || '<div class="muted">（この条件に一致する小分類はありません）</div>'}
          </div>
        </div>
        ${unclassifiedSubtopicCount(subj, topic)>0 ? `
        <div class="section">
          <h3>未分類の小分類</h3>
          <div class="list-item animated-list-item" style="animation-delay: ${subs.length * 50}ms">
            <div style="cursor:pointer" onclick="app.selectSubtopic('')" class="flex">
              <strong>未分類</strong>
              <span class="pill">${unclassifiedSubtopicCount(subj, topic)} 件</span>
              <div class="space"></div>
              <button class="ghost" onclick="event.stopPropagation();app.startSubtopic('', false)">順番</button>
              <button class="ghost" onclick="event.stopPropagation();app.startSubtopic('', true)">ランダム</button>
            </div>
          </div>
        </div>` : ''}
    `;
  }

  function startQueue(ids, randomize, mode){ state.sessionScheduled={}; 
    const q = (randomize ? shuffle(ids) : ids.slice());
    if (!q.length) return;
    state.reviewQueue = q;
    state.currentProblemId = q[0];
    startSession(q, randomize, mode||null);
    setActive('quiz');
  }

  function renderList(){
    const list = filtered();
    const topicLabel = state.currentTopic==='all' ? '（全て）' : state.currentTopic==='' ? '未分類' : state.currentTopic;
    const subLabel = state.currentSubtopic==='all' ? '（全て）' : state.currentSubtopic==='' ? '未分類' : state.currentSubtopic;

    const ids = list.map(p=>p.id);
    const disabled = ids.length===0? 'disabled':'';

    return `
        <div class="flex">
          ${state.currentTopic!=='all' ? `<button class="ghost" onclick="app.setActive('subtopics')"><i data-lucide="arrow-left"></i>小分類一覧</button>` : ''}
          <button class="ghost" onclick="app.setActive('topics')"><i data-lucide="arrow-left"></i>分野一覧</button>
          <button class="ghost" onclick="app.setActive('subjects')"><i data-lucide="arrow-left"></i>科目一覧</button>
          <h2 style="margin:0 .5rem">科目：${subjectLabel(state.currentSubject)} / 分野：${topicLabel} / 小分類：${subLabel}（${list.length} 件）</h2>
        </div>
        <div class="section">
          <div class="list-item flex animated-list-item" style="animation-delay: 0ms;">
            <strong>この一覧の全問題を連続演習：</strong>
            <div class="space"></div>
            <button class="ghost" ${disabled} onclick="app.startAll(false)">順番</button>
            <button class="ghost" ${disabled} onclick="app.startAll(true)">ランダム</button>
          </div>
        </div>
        <div class="section">
          ${list.length===0 ? '<div class="muted">この条件の問題はありません。</div>' :
            list.map((p, i)=>{
              const tag = latestSelfTag(p);
              const tagLabel = tag==='perfect'?'できた':tag==='unsure'?'普通':tag==='fail'?'できない':'未評価';
              const tagBadge = tag ? `<span class="pill">${tagLabel}</span>` : '<span class="pill">未評価</span>';
              return `
              <div class="list-item animated-list-item" style="animation-delay: ${(i + 1) * 50}ms;">
                <div class="flex">
                  <div class="space"><strong>${p.question}</strong></div>
                  <div class="pill">${importanceLabel(p.importance)}</div>
                  ${tagBadge}
                </div>
                <div class="section flex">
                  <button class="primary" onclick="app.startQuiz(${p.id})">この問題を解く</button>
                  <button class="ghost" onclick="app.editProblem(${p.id})">編集</button>
                  <button class="ghost danger" onclick="app.deleteProblem(${p.id})">削除</button>
                </div>
              </div>`;
            }).join('')
          }
        </div>
    `;
  }
  
  function idsForNav(){
    if (Array.isArray(state.reviewQueue) && state.reviewQueue.length){
      return state.reviewQueue.slice();
    }
    return filtered().map(p=>p.id);
  }
  function navNextId(){ const ids = idsForNav(); const i = ids.indexOf(state.currentProblemId); return (i>=0 && i<ids.length-1) ? ids[i+1] : null; }
  function navPrevId(){ const ids = idsForNav(); const i = ids.indexOf(state.currentProblemId); return (i>0) ? ids[i-1] : null; }

  function stopTimer(){ if (state.timerTick){ clearInterval(state.timerTick); state.timerTick=null; } state.timerStart=null; }
  function startTimer(){ stopTimer(); state.timerStart=Date.now(); const el=document.getElementById('timer'); if (!el) return; const fmt=(s)=>{ const m=String(Math.floor(s/60)).padStart(2,'0'); const ss=String(s%60).padStart(2,'0'); return m+':'+ss;}; el.textContent='00:00'; state.timerTick=setInterval(()=>{ const secs=Math.floor((Date.now()-state.timerStart)/1000); el.textContent=fmt(secs); }, 500); }

  function renderQuiz(){
    const p = state.problems.find(x=>x.id===state.currentProblemId);
    if (!p) { setActive('subjects'); return ''; }
    const prevExists = !!navPrevId();
    const nextExists = !!navNextId();
    const backButtonTarget = (sessionsState.current?.context?.mode?.startsWith('review')) ? 'review' : 'list';

    const html = `
      <div class="card">
        <div class="flex">
          <button class="back-to-list ghost" onclick="app.setActive('${backButtonTarget}')"><i data-lucide="arrow-left"></i>戻る</button>
          <div class="space"></div>
          <div class="small">タイマー：<span id="timer" class="timer">00:00</span></div><div class="small muted" style="margin-left:.75rem">入力モード：${getInputMode()==="cloze"?"穴埋め":"全文"}</div>
        </div>
        <div class="section problem-block"><div class="flex"><div class="chips"><span class="pill">${p.subject||"—"}</span>${p.topic? `<span class="pill">${p.topic}</span>` : ""}${p.subtopic? `<span class="pill">${p.subtopic}</span>` : ""}</div><div class="space"></div></div><h2 class="problem-title">Q: ${p.question}</h2></div><div class="section">
          <textarea id="answer" ${ (getInputMode()==='cloze' && (p.keywords||[]).length) ? 'style="display:none"' : '' }></textarea>
          ${(function(){
            try{
              if (getInputMode()!=='cloze') return '';
              const kws = (p.keywords||[]);
              if (!kws.length) return '';
              const masked = buildClozeNumbered(p.example || "", kws);
              const inputs = kws.map((_,i)=>`<div class="cell"><span class="n">[${i+1}]</span><input type="text" id="cloze-${i+1}" placeholder="キーワード ${i+1}"></div>`).join('');
              return `<div class="section"><strong>穴埋め（番号）</strong><div class="cloze-card">${masked || '（模範解答が未登録です）'}</div></div>
                      <div class="section"><label>番号ごとにキーワードを入力</label><div class="cloze-inputs">${inputs}</div></div>`;
            }catch(_){ return ''; }
          })()}
          <div class="section flex">
            ${prevExists ? `<button class="ghost" onclick="app.prev()"><i data-lucide="arrow-left"></i>前の問題へ</button>` : ""}
            <button class="primary" id="btn-grade" onclick="app.grade()" title="ショートカット: ⌘/Ctrl + Enter">採点する</button>
            ${nextExists ? `<button class="ghost" onclick="app.next()">次の問題へ<i data-lucide="arrow-right"></i></button>` : ""}
          </div>
          <div class="small muted">ショートカット：採点 <span class="kbd">⌘</span>/<span class="kbd">Ctrl</span>+<span class="kbd">Enter</span>、前へ <span class="kbd">K</span>、次へ <span class="kbd">J</span>、自己評価 <span class="kbd">1</span>/<span class="kbd">2</span>/<span class="kbd">3</span></div>
        </div>
        <div id="result" class="section"></div>
      </div>
    `;
    setTimeout(startTimer, 0);
    return html;
  }

  function getReviewCycleLabel(p) {
    const lastAnswer = lastAnswerYmdLocal(p);
    if (!lastAnswer) return '初回';

    const ladder = [1, 7, 14, 30];
    if (p.inReview && typeof p.stage === 'number' && p.stage >= 0 && p.stage < ladder.length) {
        return `${ladder[p.stage]}日後サイクル`;
    }
    
    // フォールバックとして経過日数を表示
    const days = daysBetweenLocal(todayStr(), lastAnswer);
    return `${days}日経過`;
  }

  function renderReview(){
    const dueToday = getDueTodayIds();
    const weakUnsure = state.problems.filter(p => latestSelfTag(p)==='unsure').map(p=>p.id);
    const weakFail   = state.problems.filter(p => latestSelfTag(p)==='fail').map(p=>p.id);
    
    const dueTodayJson = JSON.stringify(dueToday);
    const weakUnsureJson = JSON.stringify(weakUnsure);
    const weakFailJson = JSON.stringify(weakFail);

    const todayListHtml = state.reviewTodayListVisible ? `
      <div class="review-details-list">
        ${dueToday.length > 0 ? dueToday.map((id, i) => {
          const p = idToProb(id);
          const lastAnswerDate = lastAnswerYmdLocal(p);
          const nextReviewDate = getNextReviewDate(p);
          const kisanbiHtml = lastAnswerDate ? `<span class="muted small" style="flex-shrink: 0;">起算日: ${lastAnswerDate}</span>` : '';
          const yoteibiHtml = nextReviewDate ? `<span class="muted small" style="flex-shrink: 0;">予定日: ${nextReviewDate}</span>` : '';
          return `
            <div class="review-detail-item animated-list-item" style="animation-delay: ${i * 40}ms;">
              <span class="timing-tag">${getReviewCycleLabel(p)}</span>
              <span class="space">${escapeHtml(p.question)}</span>
              ${kisanbiHtml}
              ${yoteibiHtml}
              <button class="ghost" onclick="app.startQuiz(${p.id}, 'review_list')">解く</button>
            </div>
          `;
        }).join('') : '<p class="muted small" style="text-align: center;">今日復習する問題はありません。</p>'}
      </div>
    ` : '';

    const importanceOptions = `
      <option value="all">すべて</option>
      ${IMPORTANCES.map(im => `<option value="${im}">${importanceLabel(im)}</option>`).join('')}
    `;

    const html = `
        <h2>復習</h2>
        <div class="review-tabs">
          <button class="review-tab ${state.reviewTab === 'today' ? 'active' : ''}" onclick="app.setReviewTab('today')">今日の復習</button>
          <button class="review-tab ${state.reviewTab === 'weak' ? 'active' : ''}" onclick="app.setReviewTab('weak')">弱点ドリル</button>
          <button class="review-tab ${state.reviewTab === 'custom' ? 'active' : ''}" onclick="app.setReviewTab('custom')">カスタム演習</button>
        </div>

        <div id="tab-today" class="tab-content ${state.reviewTab === 'today' ? 'active' : ''}">
          <div class="action-card primary animated-list-item" style="cursor: pointer;" onclick="app.toggleReviewTodayList()">
            <i data-lucide="calendar-check" class="icon"></i>
            <h3 class="title">今日やる問題 (${dueToday.length}件)</h3>
            <p class="description">間隔反復に基づき、今日復習すべき問題です。クリックして一覧を表示します。</p>
            <div class="actions">
              <button class="ghost" style="background: #fff; color: var(--accent);" ${dueToday.length === 0 ? 'disabled' : ''} onclick='event.stopPropagation(); app.startQueue(${dueTodayJson}, false, "review_today")'>順番に解く</button>
              <button class="ghost" style="background: #fff; color: var(--accent);" ${dueToday.length === 0 ? 'disabled' : ''} onclick='event.stopPropagation(); app.startQueue(${dueTodayJson}, true, "review_today")'>ランダムで解く</button>
            </div>
          </div>
          ${todayListHtml}
        </div>

        <div id="tab-weak" class="tab-content ${state.reviewTab === 'weak' ? 'active' : ''}">
          <div class="action-card animated-list-item">
            <i data-lucide="target" class="icon"></i>
            <h3 class="title">弱点ドリル</h3>
            <p class="description">過去の評価に基づき、苦手な問題を重点的に復習します。</p>
            <div class="row-sm" style="justify-content: center;">
              <label class="small">件数</label>
              <input type="number" id="wdN" min="1" step="1" value="20" style="max-width:8rem">
              <button class="ghost" id="btnWdStart">開始</button>
            </div>
          </div>
        </div>

        <div id="tab-custom" class="tab-content ${state.reviewTab === 'custom' ? 'active' : ''}">
          <div class="action-card animated-list-item">
            <i data-lucide="shuffle" class="icon"></i>
            <h3 class="title">科目横断ランダム出題</h3>
            <p class="description">全ての科目からランダムで問題を出題します。</p>
            <div class="row-sm" style="justify-content: center;">
              <label class="small">件数</label>
              <input type="number" id="randN" min="1" step="1" value="10" style="max-width:8rem">
              <label class="small">重要度</label>
              <select id="randImp">
                ${importanceOptions}
              </select>
              <button class="ghost" id="btnRandStart">開始</button>
            </div>
          </div>
        </div>
    `;
    
    setTimeout(() => {
        const btnWdStart = document.getElementById('btnWdStart');
        if (btnWdStart) {
          btnWdStart.onclick = ()=>{
            const n = Math.max(1, Number((document.getElementById('wdN')||{}).value||20));
            const ids = state.problems.map(p=>p.id);
            const queue = buildWeakDrillWeighted(ids, config.mixRatio, n, true);
            startQueue(queue, false, 'review_weak');
          };
        }
        
        const btnRandStart = document.getElementById('btnRandStart');
        if(btnRandStart) {
          btnRandStart.onclick = ()=>{
            const n = Math.max(1, Number((document.getElementById('randN')||{}).value||10));
            const impSel = (document.getElementById('randImp')||{}).value || 'all';
            let arr = state.problems.slice();
            if (impSel !== 'all'){ arr = arr.filter(p => p.importance === impSel); }
            arr = shuffle(arr);
            const ids = arr.slice(0, n).map(p=>p.id);
            startQueue(ids, false, 'review_custom');
          };
        }
    }, 0);

    return html;
  }
  
  function renderAdd(){
    const subjectOptions = `
      <optgroup label="必修科目">
        ${CORE_SUBJECTS.map(s=>`<option>${s}</option>`).join('')}
      </optgroup>
      <optgroup label="選択科目">
        <option value="__ELECTIVE__">選択科目</option>
      </optgroup>
    `;
    const defaultSubject = state.currentSubject || CORE_SUBJECTS[0];
    const html = `
      <div class="card">
        <h2>新しい問題を追加</h2>
        <div class="home-grid">
          <div>
            <label>科目</label>
            <select id="f-subject">${subjectOptions}</select>
          </div>
          <div>
            <label>重要度</label>
            <select id="f-importance">${IMPORTANCES.map(im=>`<option value="${im}">${importanceLabel(im)}</option>`).join('')}</select>
          </div>
        </div>
        <div class="section">
          <label>分野</label>
          <div id="f-topic-area"></div>
        </div>
        <div class="section">
          <label>小分類</label>
          <div id="f-subtopic-area"></div>
        </div>
        <div class="section">
          <label>問題文</label>
          <textarea id="f-question"></textarea>
        </div>
        <div class="section">
          <label>模範解答</label>
          <textarea id="f-example"></textarea>
        </div>
        <div class="section">
          <label>重要キーワード（カンマ/句点区切り・任意）</label>
          <input id="f-keywords">
        </div>
        <div class="section">
          <label>補足情報（採点には影響しないメモ）</label>
          <textarea id="f-note"></textarea>
        </div>
        <div class="section flex">
          <button class="primary" onclick="app.addSubmit()">追加する</button>
        </div>
      </div>
    `;
    
    setTimeout(() => {
        const sel = document.getElementById('f-subject');
        if (!sel) return;
        sel.value = defaultSubject;

        function mountTopic(){
          document.getElementById('f-topic-area').innerHTML = buildTopicSelectHTML(sel.value, '');
          bindTopicHandlers();
          mountSubtopic();
        }
        function currentTopicValue(){
          const tSel = document.getElementById('f-topic');
          if (!tSel) return (document.getElementById('f-topic-new')?.value||'').trim();
          if (tSel.value === "__NEW__") return (document.getElementById('f-topic-new')?.value||'').trim();
          return tSel.value;
        }
        function mountSubtopic(){
          const topicVal = currentTopicValue();
          document.getElementById('f-subtopic-area').innerHTML = buildSubtopicSelectHTML(sel.value, topicVal, '');
          bindSubtopicHandlers();
        }
        function bindTopicHandlers(){
          const tSel = document.getElementById('f-topic');
          const tNewWrap = document.getElementById('f-topic-new-wrap');
          if (tSel){
            tSel.addEventListener('change', ()=>{
              if (tSel.value === "__NEW__"){
                if (tNewWrap) tNewWrap.classList.remove('hidden');
              }else{
                if (tNewWrap) tNewWrap.classList.add('hidden');
              }
              mountSubtopic();
            });
          }
        }
        function bindSubtopicHandlers(){
          const sSel = document.getElementById('f-subtopic');
          const sNewWrap = document.getElementById('f-subtopic-new-wrap');
          if (sSel){
            sSel.addEventListener('change', ()=>{
              if (sSel.value === "__NEW__"){
                if (sNewWrap) sNewWrap.classList.remove('hidden');
              }else{
                if (sNewWrap) sNewWrap.classList.add('hidden');
              }
            });
          }
        }

        sel.addEventListener('change', ()=>{ mountTopic(); });
        mountTopic();
    }, 0);

    return html;
  }

  function buildTopicSelectHTML(subject, currentValue){
    const topics = topicsForSubject(subject);
    if (topics.length === 0) {
      return `<input id="f-topic-new" placeholder="新しい分野名を入力（未分類可）" value="${escapeHtml(currentValue||'')}">`;
    }
    const opts = ['<option value="">（未分類）</option>']
      .concat(topics.map(t=>`<option value="${t.replace(/"/g,'&quot;')}" ${currentValue===t?'selected':''}>${t}</option>`))
      .concat([`<option value="__NEW__">（新規作成…）</option>`])
      .join('');
    return `
      <select id="f-topic">${opts}</select>
      <div class="inline ${currentValue && !topics.includes(currentValue)?'':'hidden'}" id="f-topic-new-wrap" style="margin-top: .5rem;">
        <input id="f-topic-new" placeholder="新しい分野名" value="${escapeHtml(currentValue||'')}">
      </div>`;
  }
  function buildSubtopicSelectHTML(subject, topic, currentValue){
    const subs = subtopicsFor(subject, topic);
    if (subs.length === 0) {
      return `<input id="f-subtopic-new" placeholder="新しい小分類名を入力（未分類可）" value="${escapeHtml(currentValue||'')}">`;
    }
    const opts = ['<option value="">（未分類）</option>']
      .concat(subs.map(t=>`<option value="${t.replace(/"/g,'&quot;')}" ${currentValue===t?'selected':''}>${t}</option>`))
      .concat([`<option value="__NEW__">（新規作成…）</option>`])
      .join('');
    return `
      <select id="f-subtopic">${opts}</select>
      <div class="inline ${currentValue && !subs.includes(currentValue)?'':'hidden'}" id="f-subtopic-new-wrap" style="margin-top: .5rem;">
        <input id="f-subtopic-new" placeholder="新しい小分類名" value="${escapeHtml(currentValue||'')}">
      </div>`;
  }

  function renderEdit(){
    const prob = state.problems.find(x=>x.id===state.currentProblemId);
    if (!prob){ setActive('list'); return ''; }
    const subjectOptions = `
      <optgroup label="必修科目">
        ${CORE_SUBJECTS.map(s=>`<option ${prob.subject===s?'selected':''}>${s}</option>`).join('')}
      </optgroup>
      <optgroup label="選択科目">
        <option value="__ELECTIVE__" ${prob.subject==='__ELECTIVE__'?'selected':''}>選択科目</option>
        ${ELECTIVE_SUBJECTS.map(s=>`<option ${prob.subject===s?'selected':''}>${s}</option>`).join('')}
      </optgroup>
    `;
    const html = `
      <div class="card">
        <div class="flex">
          <button class="back-to-list ghost" onclick="app.setActive('list')"><i data-lucide="arrow-left"></i>問題一覧</button>
          <h2 style="margin:0 .5rem">問題の編集</h2>
        </div>
        <div class="home-grid section">
          <div>
            <label>科目</label>
            <select id="e-subject">${subjectOptions}</select>
          </div>
          <div>
            <label>重要度</label>
            <select id="e-importance">
              ${IMPORTANCES.map(im=>`<option value="${im}" ${prob.importance===im?'selected':''}>${importanceLabel(im)}</option>`).join('')}
            </select>
          </div>
        </div>
        <div class="section">
          <label>分野</label>
          <div id="e-topic-area"></div>
        </div>
        <div class="section">
          <label>小分類</label>
          <div id="e-subtopic-area"></div>
        </div>
        <div class="section">
          <label>問題文</label>
          <textarea id="e-question">${escapeHtml(prob.question||'')}</textarea>
        </div>
        <div class="section">
          <label>模範解答</label>
          <textarea id="e-example">${escapeHtml(prob.example||'')}</textarea>
        </div>
        <div class="section">
          <label>重要キーワード（カンマ/句点区切り・任意）</label>
          <input id="e-keywords" value="${escapeHtml((prob.keywords||[]).join('、'))}">
        </div>
        <div class="section">
          <label>補足情報（採点には影響しないメモ）</label>
          <textarea id="e-note">${escapeHtml(prob.note||'')}</textarea>
        </div>
        <div class="section flex">
          <button class="primary" onclick="app.saveEdit()">保存する</button>
          <button class="ghost danger" onclick="app.deleteProblem(${prob.id})">削除</button>
        </div>
      </div>
    `;

    setTimeout(() => {
        const sel = document.getElementById('e-subject');
        if (!sel) return;
        function mountTopic(){
          document.getElementById('e-topic-area').innerHTML = buildTopicSelectEditHTML(sel.value, prob.topic||'');
          bindTopicHandlers();
          mountSubtopic();
        }
        function currentTopicValue(){
          const tSel = document.getElementById('e-topic');
          if (!tSel) return (document.getElementById('e-topic-new')?.value||'').trim();
          if (tSel.value === "__NEW__") return (document.getElementById('e-topic-new')?.value||'').trim();
          return tSel.value;
        }
        function mountSubtopic(){
          const topicVal = currentTopicValue();
          document.getElementById('e-subtopic-area').innerHTML = buildSubtopicSelectEditHTML(sel.value, topicVal, prob.subtopic||'');
          bindSubtopicHandlers();
        }
        function bindTopicHandlers(){
          const tSel = document.getElementById('e-topic');
          const tNewWrap = document.getElementById('e-topic-new-wrap');
          if (tSel){
            tSel.addEventListener('change', ()=>{
              if (tSel.value === "__NEW__"){
                if (tNewWrap) tNewWrap.classList.remove('hidden');
              }else{
                if (tNewWrap) tNewWrap.classList.add('hidden');
              }
              mountSubtopic();
            });
          }
        }
        function bindSubtopicHandlers(){
          const sSel = document.getElementById('e-subtopic');
          const sNewWrap = document.getElementById('e-subtopic-new-wrap');
          if (sSel){
            sSel.addEventListener('change', ()=>{
              if (sSel.value === "__NEW__"){
                if (sNewWrap) sNewWrap.classList.remove('hidden');
              }else{
                if (sNewWrap) sNewWrap.classList.add('hidden');
              }
            });
          }
        }
        sel.addEventListener('change', mountTopic);
        mountTopic();
    }, 0);
    return html;
  }
  
  function buildTopicSelectEditHTML(subject, currentValue){
    const topics = topicsForSubject(subject);
    if (topics.length === 0) {
      return `<input id="e-topic-new" placeholder="新しい分野名を入力（未分類可）" value="${escapeHtml(currentValue||'')}">`;
    }
    const opts = ['<option value="">（未分類）</option>']
      .concat(topics.map(t=>`<option value="${t.replace(/"/g,'&quot;')}" ${currentValue===t?'selected':''}>${t}</option>`))
      .concat([`<option value="__NEW__">（新規作成…）</option>`])
      .join('');
    const needNew = currentValue && !topics.includes(currentValue);
    return `
      <select id="e-topic">${opts}</select>
      <div class="inline ${needNew?'':'hidden'}" id="e-topic-new-wrap" style="margin-top: .5rem;">
        <input id="e-topic-new" placeholder="新しい分野名" value="${escapeHtml(currentValue||'')}">
      </div>`;
  }
  function buildSubtopicSelectEditHTML(subject, topic, currentValue){
    const subs = subtopicsFor(subject, topic);
    if (subs.length === 0) {
      return `<input id="e-subtopic-new" placeholder="新しい小分類名を入力（未分類可）" value="${escapeHtml(currentValue||'')}">`;
    }
    const opts = ['<option value="">（未分類）</option>']
      .concat(subs.map(t=>`<option value="${t.replace(/"/g,'&quot;')}" ${currentValue===t?'selected':''}>${t}</option>`))
      .concat([`<option value="__NEW__">（新規作成…）</option>`])
      .join('');
    const needNew = currentValue && !subs.includes(currentValue);
    return `
      <select id="e-subtopic">${opts}</select>
      <div class="inline ${needNew?'':'hidden'}" id="e-subtopic-new-wrap" style="margin-top: .5rem;">
        <input id="e-subtopic-new" placeholder="新しい小分類名" value="${escapeHtml(currentValue||'')}">
      </div>`;
  }
  
  function renderSettings(){
    const html = `
      <div class="card">
        <h2>設定 / データ管理</h2>

        <div class="settings-section">
          <h3>アプリケーション設定</h3>
          <div class="settings-content">
            <div class="settings-item">
              <div class="settings-item-info">
                <strong>端末に自動保存</strong>
                <p class="muted">ブラウザ内に学習データを自動で保存します。</p>
              </div>
              <div class="settings-item-control">
                <label class="switch">
                  <input type="checkbox" id="cfg-local">
                  <span class="slider"></span>
                </label>
              </div>
            </div>
            <div class="settings-item">
              <div class="settings-item-info">
                <strong>起動時に自動復元</strong>
                <p class="muted">アプリ起動時に自動でデータを読み込みます。</p>
              </div>
              <div class="settings-item-control">
                <label class="switch">
                  <input type="checkbox" id="cfg-restore">
                  <span class="slider"></span>
                </label>
              </div>
            </div>
             <div class="settings-item">
              <div class="settings-item-info">
                <strong>iPhone/iPadで起動時に案内を表示</strong>
                <p class="muted">手動でのインポート/エクスポート案内を表示します。</p>
              </div>
              <div class="settings-item-control">
                <label class="switch">
                  <input type="checkbox" id="cfg-ios-import-popup">
                  <span class="slider"></span>
                </label>
              </div>
            </div>
          </div>
        </div>
        
        <div class="settings-section">
          <h3>ドリル設定</h3>
          <div class="settings-content">
            <p class="muted small">弱点ドリルの出題比率を設定します。（普通 / できない / その他）</p>
            <div class="row-sm">
              <input type="number" id="cfg-mix-u" min="0" step="1" style="max-width:6rem">
              <input type="number" id="cfg-mix-f" min="0" step="1" style="max-width:6rem">
              <input type="number" id="cfg-mix-o" min="0" step="1" style="max-width:6rem">
            </div>
          </div>
        </div>

        <div class="settings-section">
          <h3>データ操作</h3>
          <div class="settings-content">
            <p class="muted small">PCのChrome/EdgeブラウザでiCloud Driveなどのクラウド上のJSONファイルと直接同期できます。</p>
            <div class="row-sm">
              <button class="ghost" onclick="app.pickFile()">ファイルを選択...</button>
              <button class="ghost" onclick="app.tryRestoreFileHandle(true)">再接続</button>
            </div>
            <p class="muted small" style="margin-top: 1rem;">現在の学習データをファイルとして書き出したり、ファイルから読み込んだりします。</p>
            <div class="row-sm">
              <input type="file" id="file" accept="application/json" />
              <button class="ghost" id="btn-import">インポート</button>
              <button class="ghost" id="btn-export">エクスポート</button>
            </div>
          </div>
        </div>

        <div class="settings-section">
          <h3>全般</h3>
          <div class="settings-content">
            <div class="row-sm">
              <button class="ghost" id="btn-save-cfg">設定を保存</button>
              <button class="ghost danger" id="btn-clear">ローカルキャッシュを消去</button>
            </div>
          </div>
        </div>
      </div>
    `;
    setTimeout(() => {
        document.getElementById('cfg-local').checked = !!config.autoLocalSave;
        document.getElementById('cfg-restore').checked = !!config.autoRestore;
        document.getElementById('cfg-ios-import-popup').checked = !!config.iosShowImportAtBoot;
        
        document.getElementById('cfg-mix-u').value = Number(config.mixRatio?.unsure||0);
        document.getElementById('cfg-mix-f').value = Number(config.mixRatio?.fail||0);
        document.getElementById('cfg-mix-o').value = Number(config.mixRatio?.other||0);

        document.getElementById('btn-save-cfg').onclick = ()=>{
          config.autoLocalSave = document.getElementById('cfg-local').checked;
          config.autoRestore = document.getElementById('cfg-restore').checked;
          config.iosShowImportAtBoot = document.getElementById('cfg-ios-import-popup').checked;
          config.mixRatio = {
            unsure: Number(document.getElementById('cfg-mix-u').value||0),
            fail:   Number(document.getElementById('cfg-mix-f').value||0),
            other:  Number(document.getElementById('cfg-mix-o').value||0)
          };
          saveConfig();
          showToast('設定を保存しました。');
        };
        document.getElementById('btn-clear').onclick = ()=>{
          clearLocal();
          showToast("ローカルキャッシュを消去しました。");
        };
        document.getElementById('btn-import').onclick = ()=>{
          const f = document.getElementById('file').files[0];
          if (!f) { showToast("ファイルを選択してください。", "error"); return; }
          handleImportFile(f, true);
        };
        document.getElementById('btn-export').onclick = ()=>{
          doExport("problems.json");
        };
    }, 0);
    return html;
  }

  function handleImportFile(file, notify=true, after){
    const reader = new FileReader();
    reader.onload = ()=>{
      try{
        const data = JSON.parse(reader.result);
        sanitizeProblems(data);
        state.problems = data;
        reindex();
        saveLocal(state.problems, sessionsState.logs);
        scheduleFileSave();
        updateNavBadges();
        if (notify) showToast("インポートしました。", "success");
        setActive('subjects');
        if (after) after();
      }catch(e){ showToast("JSONの解析に失敗: " + e.message, "error"); }
    };
    reader.readAsText(file, "utf-8");
  }

  function doExport(filename){
    const blob = new Blob([JSON.stringify(state.problems, null, 2)], {type:"application/json"});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename || "problems.json";
    a.click();
    URL.revokeObjectURL(a.href);
  }

  function showToast(message, type = 'info') {
    const container = document.getElementById('toast-container');
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    container.appendChild(toast);

    setTimeout(() => {
        toast.style.animation = 'toast-out 0.5s forwards';
        toast.addEventListener('animationend', () => {
            toast.remove();
        });
    }, 3000);
  }
  
  function closeModal() {
    const modalRoot = document.getElementById('modal-root');
    const mask = modalRoot.querySelector('.mask');
    document.body.classList.remove('modal-open');
    if (mask) {
        mask.classList.add('closing');
        mask.addEventListener('animationend', () => {
            modalRoot.innerHTML = '';
        }, { once: true });
    }
  }

  function showModal(content) {
      document.body.classList.add('modal-open');
      const modalRoot = document.getElementById('modal-root');
      modalRoot.innerHTML = `<div class="mask"><div class="modal">${content}</div></div>`;
      modalRoot.querySelector('.mask').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
          closeModal();
        }
      });
  }

  function showIOSImportModal() {
    showModal(`
      <h3>ようこそ</h3>
      <p>iPhone/iPadでは、データの保存に手動でのインポート/エクスポートが必要です。</p>
      <p>PCで作成した <code>problems.json</code> ファイルをお持ちの場合は、下のボタンからインポートしてください。</p>
      <div class="section flex">
        <input type="file" id="ios-import-file" accept="application/json" class="hidden">
        <button class="primary" onclick="document.getElementById('ios-import-file').click()">ファイルを選択してインポート</button>
        <button class="ghost" onclick="app.closeModal()">閉じる</button>
      </div>
    `);
    document.getElementById('ios-import-file').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        handleImportFile(file, true, () => {
          closeModal();
        });
      }
    });
  }

  function exitFlow() {
    if (IS_IPHONE && config.iosShowExportGuide) {
      showModal(`
        <h3>データをエクスポートしますか？</h3>
        <p>iPhone/iPadでは、データをファイルとして保存（エクスポート）し、安全な場所に保管することを推奨します。</p>
        <p class="muted small">次回利用時にこのファイルをインポートすることで、学習データを復元できます。</p>
        <div class="section flex">
          <button class="primary" onclick="app.doExport('problems.json'); app.closeModal()">エクスポート</button>
          <button class="ghost" onclick="app.closeModal()">キャンセル</button>
        </div>
      `);
    }
  }


  (async function boot(){
    try{
      let loaded = false;
      if (await tryRestoreFileHandle(true)){
        loaded = true;
      }
      if (!loaded && config.autoRestore){
        const cached = loadLocal();
        if (cached && Array.isArray(cached.problems)) {
          try {
            sanitizeProblems(cached.problems);
            state.problems = cached.problems;
            if (Array.isArray(cached.sessions)) sessionsState.logs = cached.sessions;
            loaded = true;
          } catch(e) {}
        }
      }
      if (!loaded){
        state.problems = [];
      }
      reindex();
      state.view = 'home';
      const ui = loadUI() || {};
      state.currentImportance = ui.currentImportance || 'all';
      state.currentSelf = ui.currentSelf || 'all';
      
      setActive(state.view);
      
      // Wire up nav and mode buttons
      document.body.addEventListener('click', (e) => {
        const navEl = e.target.closest('[data-nav]');
        if (navEl) {
          const view = navEl.getAttribute('data-nav');
          if (view === 'exit') {
            exitFlow();
          } else if (view) {
            setActive(view);
          }
        }
      });
      
      document.querySelectorAll('.btn-mode-full').forEach(el => el.addEventListener('click', () => setInputMode('full')));
      document.querySelectorAll('.btn-mode-cloze').forEach(el => el.addEventListener('click', () => setInputMode('cloze')));
      updateInputModeUI();
      
      if (IS_IPHONE && config.iosShowImportAtBoot) {
        showIOSImportAtBoot();
      }

    }catch(e){ showError(e); }
  })();

  // Expose functions to global scope for onclick handlers
  return {
    setActive,
    closeModal,
    selectSubject: (s)=>{ state.currentSubject = s; state.currentTopic='all'; state.currentSubtopic='all'; setActive('topics'); },
    selectElective: ()=>{ state.currentSubject = ELECTIVE_GROUP; state.currentTopic='all'; state.currentSubtopic='all'; setActive('topics'); },
    selectTopic: (t)=>{ state.currentTopic = t; state.currentSubtopic = 'all'; setActive((t==='all') ? 'list' : 'subtopics'); },
    startSubjectAll: (rnd)=>{ let ids = problemsBySubjectFiltered(state.currentSubject).map(p => p.id); const n = getSubjectCount(); ids = pickWithLimit(ids, n, rnd); startQueue(ids, false, 'subject_all'); },
    startTopic: (topic, rnd)=>{ let ids = idsByTopic(state.currentSubject, topic).map(id=>idToProb(id)).filter(Boolean).filter(meetsFilters).map(p => p.id); const n = getSubjectCount(); ids = pickWithLimit(ids, n, rnd); startQueue(ids, false, 'topic'); },
    selectSubtopic: (st)=>{ state.currentSubtopic = st; setActive('list'); },
    startTopicAll: (rnd)=>{ let ids = idsByTopic(state.currentSubject, state.currentTopic).map(id=>idToProb(id)).filter(Boolean).filter(meetsFilters).map(p => p.id); const n = getSubjectCount(); ids = pickWithLimit(ids, n, rnd); startQueue(ids, false, 'topic_all'); },
    startSubtopic: (st, rnd)=>{ let ids = idsBySubtopic(state.currentSubject, state.currentTopic, st).map(id=>idToProb(id)).filter(Boolean).filter(meetsFilters).map(p => p.id); const n = getSubjectCount(); ids = pickWithLimit(ids, n, rnd); startQueue(ids, false, 'subtopic'); },
    startAll: (rnd)=>{ let base = filtered().map(p=>p.id); const n = getSubjectCount(); const chosen = pickWithLimit(base, n, rnd); startQueue(chosen, false, 'list_all'); },
    startQuiz: (id, mode)=>{ state.currentProblemId = id; startSession([id], false, mode); setActive('quiz'); },
    editProblem: (id)=>{ state.currentProblemId = id; setActive('edit'); },
    deleteProblem: (id)=>{ const target = state.problems.find(p=>p.id===id); if (!target) return; if (confirm(`次の問題を削除します。よろしいですか？\n\n「${target.question}」`)) { state.problems = state.problems.filter(p=>p.id!==id); reindex(); saveLocal(state.problems, sessionsState.logs); scheduleFileSave(); updateNavBadges(); render(); } },
    prev: ()=>{ const id=navPrevId(); if (id){ state.currentProblemId=id; render(); } },
    next: ()=>{ const useQueue = Array.isArray(state.reviewQueue) && state.reviewQueue.length; if (useQueue && state.lastGradedProblemId === state.currentProblemId && state.lastGradedScore){   const ids = state.reviewQueue.slice();   const curId = state.currentProblemId;   const idx = ids.indexOf(curId);   let nextId = null;   if (state.lastGradedScore === "◎"){     if (idx >= 0) ids.splice(idx, 1);     state.reviewQueue = ids;     nextId = (idx < ids.length) ? ids[idx] : null;   } else {     ids.push(curId);     state.reviewQueue = ids;     nextId = (idx >= 0 && idx < ids.length-1) ? ids[idx+1] : null;   }   if (nextId){ state.currentProblemId = nextId; render(); }   else {     const resultEl = document.getElementById("result");     if (resultEl){ resultEl.innerHTML = `<div class="section"><div class="muted">リストの出題が完了しました。</div><div class="section"><button class="primary" onclick="app.goHome()">ダッシュボードに戻る</button></div></div>`; }     endSession(); stopTimer();   }   return; } const id=navNextId(); if (id){ state.currentProblemId=id; render(); } else {   const resultEl = document.getElementById("result");   if (resultEl){ resultEl.innerHTML = `<div class="section"><div class="muted">キューの最後です。</div><div class="section"><button class="primary" onclick="app.goHome()">ダッシュボードに戻る</button></div></div>`; }   endSession(); stopTimer(); }},
    grade: ()=>{ 
      const elapsed = state.timerStart ? Math.round((Date.now()-state.timerStart)/1000) : null; 
      let txt = (document.getElementById('answer').value || '').trim(); 
      const prob = state.problems.find(x=>x.id===state.currentProblemId); 
      const __mode = (typeof getInputMode==='function') ? getInputMode() : 'full';

      // Levenshtein distance function for full text comparison
      const levenshtein = (a, b) => {
        if (a.length === 0) return b.length;
        if (b.length === 0) return a.length;
        const matrix = Array(a.length + 1).fill(null).map(() => Array(b.length + 1).fill(null));
        for (let i = 0; i <= a.length; i++) matrix[i][0] = i;
        for (let j = 0; j <= b.length; j++) matrix[0][j] = j;
        for (let i = 1; i <= a.length; i++) {
          for (let j = 1; j <= b.length; j++) {
            const cost = a[i - 1] === b[j - 1] ? 0 : 1;
            matrix[i][j] = Math.min(
              matrix[i - 1][j] + 1,      // Deletion
              matrix[i][j - 1] + 1,      // Insertion
              matrix[i - 1][j - 1] + cost // Substitution
            );
          }
        }
        return matrix[a.length][b.length];
      };
      
      // Normalization function for comparisons (removes punctuation)
      const normalizeForComp = (str) => (str || '').replace(/[.,\s\n\r、。「」（）]/g, '').toLowerCase();

      if (__mode === 'cloze' && prob && Array.isArray(prob.keywords) && prob.keywords.length){ 
        const parts = []; 
        for (let i = 1; i <= prob.keywords.length; i++){ 
          const el = document.getElementById('cloze-' + i); 
          parts.push(el ? String(el.value || '').trim() : ''); 
        } 
        txt = parts.join(' '); 
      } 
      
      const total = (prob.keywords||[]).length; 
      let matches=[], missing=[]; 
      function __norm(s){ try{ s = String(s||'').normalize('NFKC'); }catch(_){ s = String(s||''); } s = s.replace(/\s+/g,' ').trim().replace(/[、，]/g,',').replace(/[。．]/g,'.').toLowerCase(); return s; } 

      let score="✕", cls="score-bad", scoreDetail="";

      if (__mode === 'cloze' && total > 0) {
        const parts = []; 
        for (let i=1; i<=total; i++){ 
          const el = document.getElementById('cloze-'+i); 
          parts.push(el ? (el.value||'') : ''); 
        } 
        for (let i=0; i<total; i++){ 
          if (__norm(parts[i]) === __norm(prob.keywords[i])) matches.push(prob.keywords[i]); 
          else missing.push(prob.keywords[i]); 
        }
        const ratio = matches.length / total;
        if (ratio===1){ score="◎"; cls="score-okay"; } 
        else if (ratio>=0.6){ score="○"; cls="score-mid"; } 
        else if (ratio>0){ score="△"; cls="score-low"; } 
        else { score="✕"; cls="score-bad"; } 
        scoreDetail = `（${matches.length} / ${total}）`;
        matches = (prob.keywords||[]).filter(kw => __norm(txt).includes(__norm(kw))); // For highlighting
        missing = (prob.keywords||[]).filter(kw => !__norm(txt).includes(__norm(kw))); // For highlighting

      } else { // Full text mode logic
        const nTxt = __norm(txt);
        matches = (prob.keywords || []).filter(kw => nTxt.includes(__norm(kw)));
        missing = (prob.keywords || []).filter(kw => !nTxt.includes(__norm(kw)));
        
        if (total === 0) {
          score = "—";
          cls = "";
          scoreDetail = "（キーワード未設定のため採点なし）";
        } else {
          // 1. Keyword Score (80% weight)
          const keywordRatio = matches.length / total;
          const keywordScore = keywordRatio * 0.8;

          // 2. Full Text Score (20% weight)
          const userNorm = normalizeForComp(txt);
          const modelNorm = normalizeForComp(prob.example);
          let fullTextScore = 0;
          let similarity = 0;
          if (modelNorm.length > 0) {
            const distance = levenshtein(userNorm, modelNorm);
            similarity = 1 - (distance / Math.max(userNorm.length, modelNorm.length));
            fullTextScore = Math.max(0, similarity) * 0.2; // Ensure score is not negative
          }

          // 3. Total Score
          const finalScore = keywordScore + fullTextScore;
          
          if (finalScore >= 0.95) { score = "◎"; cls = "score-okay"; }
          else if (finalScore >= 0.7) { score = "○"; cls = "score-mid"; }
          else if (finalScore >= 0.4) { score = "△"; cls = "score-low"; }
          else { score = "✕"; cls = "score-bad"; }

          const keywordPercent = keywordRatio * 100;
          const fullTextPercent = Math.max(0, similarity) * 100;
          scoreDetail = `(総合: ${(finalScore * 100).toFixed(0)}% | キーワード: ${keywordPercent.toFixed(0)}% | 全文: ${fullTextPercent.toFixed(0)}%)`;
        }
      }
      
      // --- Start of simplified grading logic ---
      const t = todayStr();
      if(!state.sessionScheduled) state.sessionScheduled={};
      if(!state.sessionScheduled[prob.id]){
        const firstEver=!prob.inReview;
        if(firstEver){
          prob.inReview=true;
          prob.stage=0;
          prob.reviews=[addDaysLocal(1)];
        } else {
          const ladder=[1,7,14,30];
          let stage=(typeof prob.stage==="number"&&isFinite(prob.stage))?prob.stage:0;
          if(score==="◎"){
            if(stage>=3){
              prob.reviews=[];
              prob.inReview=false;
              prob.graduatedAt=t;
            } else {
              stage=stage+1;
              prob.stage=stage;
              prob.reviews=[addDaysLocal(ladder[stage])];
            }
          } else if(score==="○"){
            prob.stage=stage;
            prob.reviews=[addDaysLocal(3)];
          } else if(score==="△"){
            prob.stage=stage;
            prob.reviews=[addDaysLocal(1)];
          } else {
            stage=Math.max(0,stage-1);
            prob.stage=stage;
            prob.reviews=[addDaysLocal(1)];
          }
        }
        state.sessionScheduled[prob.id]=true;
      }
      // --- End of simplified grading logic ---
      prob.history = prob.history||[];  prob.history.push({date:new Date().toISOString(), score, hit:matches.length, total:total, secs: elapsed, self:null}); try { const mode = (sessionsState.current && sessionsState.current.context && sessionsState.current.context.mode) || null; if (mode === 'weak' && score === '◎') { prob.weakPoints = Math.max(0, (prob.weakPoints||0) - 3); } } catch(_) {} bumpSessionOnScore(score);
      state.lastGradedProblemId = prob.id;
      state.lastGradedScore = score; addDailyAnswered(1); saveLocal(state.problems, sessionsState.logs); scheduleFileSave(); updateNavBadges(); function escReg(s){ return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); } let escaped = escapeHtml(txt); matches.forEach(kw=>{ const re = new RegExp(escReg(kw), 'g'); escaped = escaped.replace(re, `<mark class="hit">${kw}</mark>`); }); let modelEscaped = escapeHtml(prob.example || "（登録なし）"); (prob.keywords || []).forEach(kw=>{ if (!kw) return; const re = new RegExp(escReg(kw), 'g'); const has = matches.includes(kw); modelEscaped = modelEscaped.replace(re, `<mark class="${has?'hit':'miss'}">${kw}</mark>`); }); const currentSel = (()=>{ for(let i=prob.history.length-1;i>=0;i--){ if (prob.history[i].self) return prob.history[i].self; } return null; })(); document.getElementById('result').innerHTML = ` <div class="card"> <div>評価：<span class="score ${cls}">${score}</span> ${scoreDetail} ${elapsed!=null? `<span class="muted small">（所要 ${Math.floor(elapsed/60)}分${elapsed%60}秒）</span>`:''}</div> <div class="muted section">${ total===0 ? "（キーワード未設定）" : `含まれていたキーワード：${matches.length? matches.map(k=>`<span class='kw'>${k}</span>`).join(' ') : "なし"}` }</div> ${ total>0 ? `<div class="section"><strong>抜けていたキーワード</strong><div>${missing.length? missing.map(k=>`<span class='kw kw-miss'>${k}</span>`).join(' ') : "なし"}</div></div>` : ""} <div class="section"> <label>あなたの回答（命中キーワードをハイライト）</label> <div style="white-space:pre-line;border:1px dashed #ccc;border-radius:.6rem;padding:.6rem;background:#fcfcfc">${escaped || "（未入力）"}</div> </div> <div class="section"> <strong>模範解答（命中=黄／抜け=桃）</strong> <div style="white-space:pre-line;border:1px solid #dbeafe;background:#eff6ff;border-radius:.6rem;padding:.6rem">${modelEscaped}</div> </div> ${prob.note ? `<div class="section"><strong>補足情報</strong><div class="note">${escapeHtml(prob.note)}</div></div>` : ""} <div class="section"> <strong>自己評価：</strong> <div class="flex" id="selfBtns" style="margin-top:.5rem"> <button class="ghost selfbtn ${currentSel==='perfect'?'active':''}" data-tag="perfect" onclick="app.selfMark('perfect')">できた</button> <button class="ghost selfbtn ${currentSel==='unsure'?'active':''}" data-tag="unsure" onclick="app.selfMark('unsure')">普通</button> <button class="ghost selfbtn ${currentSel==='fail'?'active':''}" data-tag="fail" onclick="app.selfMark('fail')">できない</button> </div> </div> <div class="section flex"> <button class="ghost" onclick="app.goHome()">トップへ戻る</button> ${!!navPrevId() ? `<button class="ghost" onclick="app.prev()"><i data-lucide="arrow-left"></i> 前の問題へ</button>` : ''} ${!!navNextId() ? `<button class="primary" onclick="app.next()">次の問題へ <i data-lucide="arrow-right"></i></button>` : '<span class="muted">（キューの最後です）</span>'} </div> </div> `; },
    selfMark: (tag)=>{ const prob = state.problems.find(x=>x.id===state.currentProblemId); const last = prob.history[prob.history.length-1]; if (last) last.self = tag; prob.selfStats = prob.selfStats || {perfect:0,unsure:0,fail:0}; if (tag==='perfect') prob.selfStats.perfect++; if (tag==='unsure') { prob.selfStats.unsure++; prob.weakPoints = Math.max(0, (prob.weakPoints||0) + 2); } if (tag==='fail')   { prob.selfStats.fail++;   prob.weakPoints = Math.max(0, (prob.weakPoints||0) + 3); } saveLocal(state.problems, sessionsState.logs); scheduleFileSave(); updateNavBadges(); document.querySelectorAll('.selfbtn').forEach(b=> b.classList.remove('active')); const target = Array.from(document.querySelectorAll('.selfbtn')).find(b=> b.getAttribute('data-tag')===tag); if (target) target.classList.add('active'); },
    goHome: ()=> { endSession(); stopTimer(); setActive('home'); },
    setReviewTab: (tabName) => { state.reviewTab = tabName; state.reviewTodayListVisible = false; render(); },
    toggleReviewTodayList: () => { state.reviewTodayListVisible = !state.reviewTodayListVisible; render(); },
    startQueue: (ids, rnd, mode)=> startQueue(ids, rnd, mode),
    addSubmit: ()=>{ const subject = document.getElementById('f-subject').value; let topic = ''; const tSel = document.getElementById('f-topic'); if (tSel) { topic = (tSel.value === "__NEW__") ? (document.getElementById('f-topic-new').value || '').trim() : tSel.value; } else { topic = (document.getElementById('f-topic-new').value || '').trim(); } let subtopic = ''; const sSel = document.getElementById('f-subtopic'); if (sSel) { subtopic = (sSel.value === "__NEW__") ? (document.getElementById('f-subtopic-new').value || '').trim() : sSel.value; } else { subtopic = (document.getElementById('f-subtopic-new').value || '').trim(); } const importance = document.getElementById('f-importance').value; const question = (document.getElementById('f-question').value||'').trim(); const example  = (document.getElementById('f-example').value||'').trim(); const keywordsRaw = (document.getElementById('f-keywords').value||''); const keywords = keywordsRaw ? keywordsRaw.split(KEY_SPLIT).map(s=>s.trim()).filter(Boolean) : []; const note     = (document.getElementById('f-note').value||'').trim(); if (!question) { showToast('問題文を入力してください。', 'error'); return; } state.problems.push({ id: Date.now()+Math.floor(Math.random()*1000), subject, topic, subtopic, importance, question, example, keywords, note, history:[], reviews:[], selfStats:{perfect:0,unsure:0,fail:0} }); reindex(); saveLocal(state.problems, sessionsState.logs); scheduleFileSave(); updateNavBadges(); document.getElementById('f-question').value=''; document.getElementById('f-example').value=''; document.getElementById('f-keywords').value=''; document.getElementById('f-note').value=''; showToast('問題を追加しました。', 'success'); },
    saveEdit: ()=>{ const prob = state.problems.find(x=>x.id===state.currentProblemId); const subject = document.getElementById('e-subject').value; let topic = ''; const tSel = document.getElementById('e-topic'); if (tSel) { topic = (tSel.value === "__NEW__") ? (document.getElementById('e-topic-new').value || '').trim() : tSel.value; } else { topic = (document.getElementById('e-topic-new').value || '').trim(); } let subtopic = ''; const sSel = document.getElementById('e-subtopic'); if (sSel) { subtopic = (sSel.value === "__NEW__") ? (document.getElementById('e-subtopic-new').value || '').trim() : sSel.value; } else { subtopic = (document.getElementById('e-subtopic-new').value || '').trim(); } const importance = document.getElementById('e-importance').value; const question = (document.getElementById('e-question').value||'').trim(); const example  = (document.getElementById('e-example').value||'').trim(); const keywordsRaw = (document.getElementById('e-keywords').value||''); const keywords = keywordsRaw ? keywordsRaw.split(KEY_SPLIT).map(s=>s.trim()).filter(Boolean) : []; const note     = (document.getElementById('e-note').value||'').trim(); if (!question) { showToast('問題文を入力してください。', 'error'); return; } Object.assign(prob, {subject, topic, subtopic, importance, question, example, keywords, note}); reindex(); saveLocal(state.problems, sessionsState.logs); scheduleFileSave(); updateNavBadges(); showToast('保存しました。', 'success'); },
    setImp: (v)=>{ state.currentImportance=v; render(); },
    setSelf: (v)=>{ state.currentSelf=v; render(); },
    resetFilters: ()=>{ state.currentImportance='all'; state.currentSelf='all'; render(); },
    pickFile,
    tryRestoreFileHandle,
    doExport,
  };
})();
</script>
</body>
</html>



